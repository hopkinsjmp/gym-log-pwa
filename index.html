<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Gym Log</title>

  <!-- PWA basics -->
  <meta name="theme-color" content="#111827" />
  <link rel="manifest" href="./manifest.json" />

  <!-- Nice-to-haves (Android/Chrome + iOS-ish) -->
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="GymLog" />

  <!-- Optional: you can add an iOS icon later if you want -->
  <!-- <link rel="apple-touch-icon" href="./icon-192.png" /> -->

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 16px;
      background: #111827;
      color: #f9fafb;
    }

    h1 {
      margin: 0 0 12px;
      font-size: 1.4rem;
    }

    .hint {
      margin: 0 0 12px;
      opacity: 0.75;
      font-size: 0.95rem;
      line-height: 1.3;
    }

    textarea {
      width: 100%;
      min-height: 240px;
      padding: 12px;
      font-size: 16px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: #f9fafb;
      outline: none;
      resize: vertical;
      box-sizing: border-box;
    }

    textarea:focus {
      border-color: rgba(124, 58, 237, 0.7);
      box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.25);
    }

    .row {
      display: flex;
      gap: 10px;
      margin-top: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    button {
      padding: 12px 16px;
      font-size: 16px;
      border-radius: 10px;
      border: none;
      background: #7c3aed;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }

    button.secondary {
      background: rgba(255,255,255,0.12);
      color: #f9fafb;
    }

    .status {
      font-size: 0.95rem;
      opacity: 0.85;
      min-height: 1.2em;
    }

    .tiny {
      font-size: 0.85rem;
      opacity: 0.75;
      margin-top: 10px;
      line-height: 1.35;
    }

    code {
      background: rgba(255,255,255,0.08);
      padding: 2px 6px;
      border-radius: 6px;
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* iOS-style picker wheel */
    .picker-container {
      display: flex;
      gap: 0;
      margin: 0;
      align-items: stretch;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.06);
      position: relative;
      height: 120px;
    }

    .picker-container::before,
    .picker-container::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      height: 40px;
      pointer-events: none;
      z-index: 2;
    }

    .picker-container::before {
      top: 0;
      background: linear-gradient(to bottom, rgba(11,18,32,1) 0%, rgba(11,18,32,0.85) 60%, transparent 100%);
      border-radius: 8px 8px 0 0;
    }

    .picker-container::after {
      bottom: 0;
      background: linear-gradient(to top, rgba(11,18,32,1) 0%, rgba(11,18,32,0.85) 60%, transparent 100%);
      border-radius: 0 0 8px 8px;
    }

    .picker-selection {
      position: absolute;
      left: 0;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      height: 32px;
      border-top: 0.5px solid rgba(255,255,255,0.2);
      border-bottom: 0.5px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.02);
      pointer-events: none;
      z-index: 1;
    }

    .picker-wheel {
      position: relative;
      flex: 1;
      overflow: hidden;
    }

    .picker-scroll {
      position: relative;
      padding: 44px 0;
      transition: transform 0.15s ease-out;
    }

    .picker-item {
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: 400;
      cursor: pointer;
      user-select: none;
      opacity: 0.3;
      transition: opacity 0.15s, font-size 0.15s;
    }

    .picker-item.selected {
      opacity: 1;
      font-size: 20px;
      font-weight: 500;
    }

    .picker-label {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      opacity: 0.6;
      pointer-events: none;
      z-index: 3;
      font-weight: 400;
    }

    .set-row {
      margin-bottom: 10px;
      position: relative;
    }

    .set-row .set-number {
      font-size: 13px;
      font-weight: 600;
      opacity: 0.7;
      margin-bottom: 4px;
    }

    .remove-set-btn {
      position: absolute;
      top: 0;
      right: 0;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #ef4444;
      color: white;
      border: none;
      font-size: 16px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .remove-set-btn:hover {
      background: #dc2626;
    }

    .add-set-btn {
      width: 100%;
      padding: 10px;
      margin-top: 4px;
      background: rgba(124, 58, 237, 0.15);
      border: 1px dashed rgba(124, 58, 237, 0.4);
      border-radius: 8px;
      color: #a78bfa;
      font-size: 24px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .plan-reasoning {
      background: rgba(124, 58, 237, 0.08);
      border: 1px solid rgba(124, 58, 237, 0.3);
      border-radius: 8px;
      padding: 10px 12px;
      margin-bottom: 12px;
      font-size: 13px;
      line-height: 1.5;
      color: #e9d5ff;
    }

    .plan-reasoning strong {
      display: block;
      margin-bottom: 6px;
      color: #f3e8ff;
      font-size: 13px;
    }

    .add-set-btn:hover {
      background: rgba(124, 58, 237, 0.25);
      border-color: rgba(124, 58, 237, 0.6);
    }

    /* Exercise tiles grid */
    .exercises-grid {
      display: grid;
      /* Always force exactly 3 columns so small phones show 3 tiles per row */
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 16px;
    }

    /* Make each tile square. Using aspect-ratio is the simplest modern approach. */
    .exercise-tile {
      aspect-ratio: 1 / 1;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 12px;
      text-align: center;
      min-height: 0; /* allow aspect-ratio to control height */
    }

    /* (Moved aspect-ratio styles above; keep hover & transition rules here) */
    .exercise-tile {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative; /* allow badges to be positioned inside */
      overflow: visible;
    }

    /* Unsynced count badge */
    .unsynced-badge {
      position: absolute;
      top: 8px;
      right: 8px;
      min-width: 22px;
      height: 22px;
      padding: 0 6px;
      border-radius: 999px;
      background: #ef4444; /* red */
      color: white;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      box-shadow: 0 2px 6px rgba(0,0,0,0.35);
      line-height: 1;
    }

    .exercise-tile:hover {
      background: rgba(124, 58, 237, 0.15);
      border-color: rgba(124, 58, 237, 0.4);
      transform: translateY(-2px);
    }

    .exercise-tile-name {
      font-size: 15px;
      font-weight: 600;
      line-height: 1.3;
    }

    .exercise-next {
      margin-top: 6px;
      font-size: 12px;
      opacity: 0.75;
      font-weight: 500;
    }

    .add-exercise-tile {
      background: rgba(124, 58, 237, 0.1);
      border: 1px dashed rgba(124, 58, 237, 0.3);
    }

    .add-exercise-tile:hover {
      background: rgba(124, 58, 237, 0.2);
      border-color: rgba(124, 58, 237, 0.5);
    }

    /* Exercise detail modal */
    .exercise-history {
      margin: 12px 0;
      max-height: 300px;
      overflow-y: auto;
    }

    .history-item {
      padding: 8px 10px;
      margin-bottom: 6px;
      background: rgba(255,255,255,0.04);
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
    }

    .history-date {
      opacity: 0.7;
      font-size: 12px;
    }

    .history-details {
      font-weight: 600;
    }

    .quick-add-form {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }

    .form-row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    .form-row input {
      flex: 1;
      padding: 10px;
      border-radius: 8px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.1);
      color: #f9fafb;
      font-size: 14px;
    }

    .form-row input:focus {
      outline: none;
      border-color: rgba(124, 58, 237, 0.6);
    }
  </style>
</head>

<body>
  <h1>üèãÔ∏è Gym Log</h1>
  <p class="hint">Tap an exercise to see history and log a new set.</p>

  <div class="status" id="status" style="margin-top:8px;"></div>
  <!-- removed legacy "Synced" indicator -->

  <!-- Training Plan Summary (collapsible) -->
  <div id="planSummary" style="display:none; margin:12px 0; padding:12px; background:rgba(124, 58, 237, 0.08); border:1px solid rgba(124, 58, 237, 0.3); border-radius:10px;">
    <div style="display:flex; justify-content:space-between; align-items:center; cursor:pointer;" onclick="document.getElementById('planSummaryContent').style.display = document.getElementById('planSummaryContent').style.display === 'none' ? 'block' : 'none';">
      <div style="font-weight:600; font-size:14px;">üìã Training Strategy</div>
      <div id="planSummaryDate" style="font-size:12px; opacity:0.7;"></div>
    </div>
    <div id="planSummaryContent" style="margin-top:8px; font-size:13px; line-height:1.5; display:block;"></div>
  </div>

  <!-- Generate All Plans button -->
  <div style="margin:12px 0;">
    <button id="generateAllPlansBtn" style="width:100%; padding:12px; background:#7c3aed; font-size:15px;">
      ‚ú® Generate AI Training Plan
    </button>
  </div>

  <!-- Exercise tiles grid -->
  <div id="exercisesGrid" class="exercises-grid"></div>

  <!-- Pending actions queue panel (collapsed by default) -->
  <div id="queuePanel" style="display:none; margin-top:16px; padding:10px; border-radius:8px; background:rgba(255,255,255,0.02);">
    <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
      <div style="font-weight:700">Pending sync</div>
      <div style="display:flex; gap:8px;">
        <button id="retryQueue" class="secondary" type="button">Retry all</button>
        <button id="clearQueue" class="secondary" type="button">Clear</button>
      </div>
    </div>
    <div id="queueList" style="margin-top:8px; max-height:180px; overflow:auto; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; font-size:13px;"></div>
  </div>

  <div class="tiny" id="pwaInfo"></div>

  <!-- Google Sign-In status & button -->
  <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
    <div id="gsiStatus" class="tiny" style="flex:1;">Not signed in</div>
    <div id="gsiButton"></div>
    <button id="gsiSignOut" class="secondary" style="display:none;">Sign out</button>
  </div>

  <!-- Exercise detail modal -->
  <div id="exerciseModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); align-items:center; justify-content:center; z-index:9999; overflow-y:auto; padding:20px 0;">
    <div style="background:#0b1220; padding:20px; border-radius:12px; width:92%; max-width:500px; box-shadow:0 10px 30px rgba(0,0,0,0.6); color:#f9fafb; margin:auto;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
        <h3 id="modalExerciseName" style="margin:0; font-size:1.2rem;">Exercise</h3>
        <button id="modalClose" class="secondary" style="padding:6px 12px; font-size:14px;">‚úï</button>
      </div>
      
      <!-- Recent history -->
      <div class="exercise-history" id="exerciseHistory">
        <div style="opacity:0.7; font-size:14px;">Loading history...</div>
      </div>

      <!-- Picker wheels for adding a new set -->
      <div style="margin-top:16px; padding-top:16px; border-top:1px solid rgba(255,255,255,0.1);">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <div style="font-weight:600; font-size:14px;">Log New Set</div>
          <div style="display:flex; gap:6px;">
              <button id="editPlanBtn" class="secondary" style="padding:6px 10px; font-size:12px;">Edit Plan</button>
              <button id="removeExerciseBtn" class="secondary" style="padding:6px 10px; font-size:12px; background:#ef4444;">Remove</button>
            </div>
        </div>
        <div id="planInfo" style="font-size:12px; opacity:0.7; margin-bottom:8px; display:none;"></div>
        <div id="planReasoning" class="plan-reasoning" style="display:none;">
          <strong>‚ú® AI Coach says:</strong>
          <span id="planReasoningText"></span>
        </div>
        <div style="display:flex; gap:8px;">
          <div style="flex:1">
            <div style="font-weight:500; margin-bottom:6px; font-size:13px; opacity:0.85;">Weight</div>
            <div class="picker-container" id="pickerWeight"></div>
          </div>
          <div style="width:110px">
            <div style="font-weight:500; margin-bottom:6px; font-size:13px; opacity:0.85;">Reps</div>
            <div class="picker-container" id="pickerReps"></div>
          </div>
        </div>
        <button id="quickAddSet" type="button" style="width:100%; padding:10px; margin-top:12px;">Add Set</button>
      </div>
    </div>
  </div>

  <!-- Old modals removed -->
  
  <script>
    const statusEl = document.getElementById("status");
    const pwaInfo = document.getElementById("pwaInfo");

    function flashStatus(msg, ms = 1500) {
      statusEl.textContent = msg;
      window.clearTimeout(flashStatus._t);
      flashStatus._t = window.setTimeout(() => (statusEl.textContent = ""), ms);
    }

      // Format a nextDate string into: "Tue ¬∑ 12 Mar" using local timezone
      function formatNextDate(dateStr) {
        if (!dateStr) return 'Next: ‚Äî';
        try {
          const d = new Date(dateStr);
          if (isNaN(d.getTime())) return 'Next: ‚Äî';
          const weekday = d.toLocaleDateString(undefined, { weekday: 'short' });
          const day = d.toLocaleDateString(undefined, { day: '2-digit' });
          const month = d.toLocaleDateString(undefined, { month: 'short' });
          return `Next: ${weekday} ¬∑ ${day} ${month}`;
        } catch (e) {
          return 'Next: ‚Äî';
        }
      }

    // Render exercise tiles grid
    function renderExercisesGrid() {
      const grid = document.getElementById('exercisesGrid');
      if (!grid) return;
      let exercises = loadExercises();
      
      // Sort by nextDate (soonest first), then by name
      exercises = exercises.slice().sort((a, b) => {
        const aDate = a.plan?.nextDate ? new Date(a.plan.nextDate).getTime() : Infinity;
        const bDate = b.plan?.nextDate ? new Date(b.plan.nextDate).getTime() : Infinity;
        if (aDate !== bDate) return aDate - bDate;
        return (a.name || '').localeCompare(b.name || '');
      });
      
      grid.innerHTML = '';

      // Add tile for each exercise
      const allSets = loadSets();
      const loggedIds = new Set(loadLoggedSetIds());
      exercises.forEach(ex => {
          const tile = document.createElement('div');
          tile.className = 'exercise-tile';
          // Show name and next planned date (formatted client-side)
          const nextText = ex.plan && ex.plan.nextDate ? formatNextDate(ex.plan.nextDate) : 'Next: ‚Äî';
          tile.innerHTML = `<div><div class="exercise-tile-name">${ex.name}</div><div class="exercise-next">${nextText}</div></div>`;

        // compute unsynced sets for this exercise (sets present locally but not in logged ids)
        try {
          const unsynced = allSets.filter(s => String(s.exerciseId) === String(ex.id) && s.id && !loggedIds.has(s.id));
          if (unsynced && unsynced.length > 0) {
            const badge = document.createElement('span');
            badge.className = 'unsynced-badge';
            badge.textContent = String(unsynced.length);
            tile.appendChild(badge);
          }
        } catch (e) {
          // ignore
        }

        tile.addEventListener('click', () => openExerciseModal(ex));
        grid.appendChild(tile);
      });

      // Add "+" tile for new exercise
      const addTile = document.createElement('div');
      addTile.className = 'exercise-tile add-exercise-tile';
      addTile.innerHTML = `<div class="exercise-tile-name">+ Add Exercise</div>`;
      addTile.addEventListener('click', addExercise);
      grid.appendChild(addTile);
    }

    // Open modal showing history + quick-add for an exercise
    function openExerciseModal(exercise) {
      const modal = document.getElementById('exerciseModal');
      const nameEl = document.getElementById('modalExerciseName');
      const historyEl = document.getElementById('exerciseHistory');
      const addBtn = document.getElementById('quickAddSet');
      const closeBtn = document.getElementById('modalClose');
      const loadPlanBtn = document.getElementById('loadPlanBtn');
      const editPlanBtn = document.getElementById('editPlanBtn');
      const planInfoEl = document.getElementById('planInfo');
      const planReasoningEl = document.getElementById('planReasoning');
      const planReasoningText = document.getElementById('planReasoningText');

      nameEl.textContent = exercise.name;
      historyEl.innerHTML = '<div style="opacity:0.7; font-size:14px;">Loading history...</div>';
      
      // Show plan info if exercise has a plan
      if (exercise.plan && exercise.plan.weight && exercise.plan.reps) {
        planInfoEl.textContent = `Plan: ${exercise.plan.sets || 3} sets √ó ${exercise.plan.reps} reps @ ${exercise.plan.weight}kg${exercise.plan.nextDate ? ' (next: ' + new Date(exercise.plan.nextDate).toLocaleDateString() + ')' : ''}`;
        planInfoEl.style.display = 'block';
      } else {
        planInfoEl.style.display = 'none';
      }
      
      // Show plan reasoning if it exists
      if (exercise.planReasoning) {
        planReasoningText.textContent = exercise.planReasoning;
        planReasoningEl.style.display = 'block';
      } else {
        planReasoningEl.style.display = 'none';
      }
      
      modal.style.display = 'flex';

      // Load recent sets for this exercise
      const sets = loadSets().filter(s => String(s.exerciseId) === String(exercise.id)).slice(-15).reverse();
      if (sets.length === 0) {
        historyEl.innerHTML = '<div style="opacity:0.5; font-size:14px;">No history yet</div>';
      } else {
        historyEl.innerHTML = '';
        sets.forEach(s => {
          const item = document.createElement('div');
          item.className = 'history-item';
          const date = s.ts ? new Date(s.ts).toLocaleDateString() : '';
          const details = s.reps !== undefined && s.reps !== null
            ? `${s.reps} reps @ ${s.weight || '0kg'}`
            : (s.duration_s ? `${s.duration_s}s` : '');
          item.innerHTML = `<div class="history-date">${date}</div><div class="history-details">${details}</div>`;
          historyEl.appendChild(item);
        });
      }

      // Build picker wheels for weight and reps
      const weightValues = [];
      for (let w = 0; w <= 200; w += 1) weightValues.push(w + ' kg');
      const repsValues = [];
      for (let r = 1; r <= 30; r++) repsValues.push(String(r));

      const wEl = document.getElementById('pickerWeight');
      const rEl = document.getElementById('pickerReps');
      
      // Auto-load plan values if available
      let defaultWeightIdx = 20;
      let defaultRepsIdx = 4;
      if (exercise.plan && exercise.plan.weight && exercise.plan.reps) {
        defaultWeightIdx = Math.min(exercise.plan.weight, 200);
        defaultRepsIdx = Math.min(exercise.plan.reps - 1, 29);
        
        // Show plan info
        const planInfo = document.getElementById('planInfo');
        planInfo.textContent = `Planned: ${exercise.plan.sets || 3} sets √ó ${exercise.plan.reps} @ ${exercise.plan.weight}kg`;
        planInfo.style.display = 'block';
      }
      
      // Display plan reasoning if available
      if (exercise.planReasoning) {
        const reasoningDiv = document.getElementById('planReasoning');
        const reasoningText = document.getElementById('planReasoningText');
        reasoningText.textContent = exercise.planReasoning;
        reasoningDiv.style.display = 'block';
      }
      
      const weightPicker = buildPicker(wEl, weightValues, defaultWeightIdx);
      const repsPicker = buildPicker(rEl, repsValues, defaultRepsIdx);

      // Edit Plan button: prompt for plan values
      editPlanBtn.onclick = () => {
        const weight = prompt('Plan weight (kg):', exercise.plan?.weight || 20);
        if (weight === null) return;
        const reps = prompt('Plan reps:', exercise.plan?.reps || 5);
        if (reps === null) return;
        const sets = prompt('Plan sets:', exercise.plan?.sets || 3);
        if (sets === null) return;
        const nextDate = prompt('Next workout date (YYYY-MM-DD):', exercise.plan?.nextDate ? exercise.plan.nextDate.split('T')[0] : new Date(Date.now() + 86400000*2).toISOString().split('T')[0]);
        if (nextDate === null) return;

        const plan = {
          weight: parseFloat(weight) || 0,
          reps: parseInt(reps,10) || 0,
          sets: parseInt(sets,10) || 0,
          nextDate: nextDate ? new Date(nextDate).toISOString() : null
        };
        exercise.plan = plan;
        
        // Save updated exercise locally
        const exercises = loadExercises();
        const idx = exercises.findIndex(e => e.id === exercise.id);
        if (idx >= 0) {
          exercises[idx] = exercise;
          saveExercises(exercises);
        }
        
        // Sync plan to server
        try {
          enqueueAction('upsert_exercise', JSON.stringify(exercise));
        } catch (e) {}
        
        flashStatus('Plan updated ‚úîÔ∏è', 1500);
        openExerciseModal(exercise); // refresh modal
      };

      // Remove Exercise button: deletes exercise from user list (server + local)
      const removeBtn = document.getElementById('removeExerciseBtn');
      if (removeBtn) {
        removeBtn.onclick = async () => {
          if (!confirm(`Remove exercise "${exercise.name}" from your list? This cannot be undone.`)) return;
          try {
            const res = await logActionToSheet('delete_exercise', JSON.stringify({ id: exercise.id }));
            if (res && res.ok) {
              // remove locally
              const exercises = loadExercises().filter(e => e.id !== exercise.id);
              saveExercises(exercises);
              renderExercisesGrid();
              flashStatus('Exercise removed ‚úîÔ∏è', 1600);
              // close modal
              const modal = document.getElementById('exerciseModal');
              if (modal) modal.style.display = 'none';
            } else {
              flashStatus('Failed to remove exercise', 2000);
              console.warn('delete_exercise response', res);
            }
          } catch (e) {
            flashStatus('Error removing exercise', 2000);
            console.error('delete_exercise error', e);
          }
        };
      }

      // Quick-add handler using pickers
      addBtn.onclick = async () => {
        const weightVal = weightPicker ? weightPicker.getValue() : null;
        const repsVal = repsPicker ? repsPicker.getValue() : null;
        const weightNum = weightVal ? String(weightVal).replace(' kg','').trim() : '';
        const repsNum = repsVal ? parseInt(repsVal,10) : 0;
        if (!repsNum || repsNum <= 0) return flashStatus('Enter reps', 1200);

        const sid = generateId();
        const ts = new Date().toISOString();
        const setObj = { id: sid, exerciseId: exercise.id, ts, reps: repsNum, weight: weightNum ? `${weightNum}kg` : '' };
        
        const sets = loadSets();
        sets.push(setObj);
        saveSets(sets);

        flashStatus('Set added ‚úîÔ∏è', 1200);

        // Sync to server using new Effort model
        try {
          // convert local setObj to Effort shape: id, exerciseId, performedAt, reps, weightKg, notes
          const weightKg = setObj.weight ? Number(String(setObj.weight).replace(/kg/i, '').trim()) : null;
          const effort = {
            id: setObj.id,
            exerciseId: exercise.id,
            performedAt: setObj.ts,
            reps: setObj.reps,
            weightKg: weightKg !== null && !isNaN(weightKg) ? weightKg : null,
            notes: setObj.notes || ''
          };
          await enqueueAction('log_efforts', JSON.stringify({ efforts: [effort] }));
        } catch (e) { console.warn('log_efforts failed', e); }

        // Refresh history and pickers
        openExerciseModal(exercise);
        renderExercisesGrid(); // refresh tiles to update unsynced badge
      };

      closeBtn.onclick = () => {
        modal.style.display = 'none';
      };
    }

    // Helper to build iOS-style picker wheels
    function buildPicker(el, values, initialIndex = 0) {
      // Clear
      el.innerHTML = '';
      const wheel = document.createElement('div');
      wheel.className = 'picker-wheel';
      const scroll = document.createElement('div');
      scroll.className = 'picker-scroll';
      
      values.forEach((v, i) => {
        const it = document.createElement('div');
        it.className = 'picker-item' + (i === initialIndex ? ' selected' : '');
        it.textContent = v;
        it.dataset.value = v;
        it.addEventListener('click', () => {
          // deselect siblings
          Array.from(scroll.children).forEach(c => c.classList.remove('selected'));
          it.classList.add('selected');
        });
        scroll.appendChild(it);
      });
      
      wheel.appendChild(scroll);
      el.appendChild(wheel);
      
      // Add touch scroll handling for mobile
      let startY = 0;
      let currentY = 0;
      let scrollOffset = 0;
      let isDragging = false;
      
      wheel.addEventListener('touchstart', (e) => {
        isDragging = true;
        startY = e.touches[0].clientY;
        currentY = startY;
        const transform = scroll.style.transform || 'translateY(0px)';
        scrollOffset = parseInt(transform.match(/-?\d+/)?.[0] || 0);
      }, { passive: true });
      
      wheel.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        currentY = e.touches[0].clientY;
        const delta = currentY - startY;
        scroll.style.transform = `translateY(${scrollOffset + delta}px)`;
        scroll.style.transition = 'none';
      }, { passive: false });
      
      wheel.addEventListener('touchend', (e) => {
        if (!isDragging) return;
        isDragging = false;
        const delta = currentY - startY;
        const finalOffset = scrollOffset + delta;
        
        // Snap to nearest item (each item is 32px)
        const itemHeight = 32;
        const snappedOffset = Math.round(finalOffset / itemHeight) * itemHeight;
        const maxOffset = 0;
        const minOffset = -(values.length - 1) * itemHeight;
        const clampedOffset = Math.max(minOffset, Math.min(maxOffset, snappedOffset));
        
        scroll.style.transition = 'transform 0.15s ease-out';
        scroll.style.transform = `translateY(${clampedOffset}px)`;
        
        // Update selected item
        const selectedIdx = Math.abs(Math.round(clampedOffset / itemHeight));
        Array.from(scroll.children).forEach((c, i) => {
          c.classList.toggle('selected', i === selectedIdx);
        });
        
        setTimeout(() => {
          scroll.style.transition = '';
        }, 150);
      }, { passive: true });
      
      // Scroll the selected item into view initially
      setTimeout(() => {
        const selected = scroll.querySelector('.picker-item.selected');
        if (selected) selected.scrollIntoView({ block: 'center', behavior: 'smooth' });
      }, 50);
      
      return {
        getValue: () => {
          const sel = scroll.querySelector('.picker-item.selected');
          return sel ? sel.dataset.value : null;
        }
      };
    }

    async function addExercise() {
      const name = prompt('Exercise name (e.g. Bench Press)');
      if (!name) return flashStatus('Cancelled', 1200);
      const exercises = loadExercises();
      const ex = { id: generateId(), name: name.trim(), notes: '' };
      exercises.push(ex);
      saveExercises(exercises);
      flashStatus('Exercise added ‚úîÔ∏è');
      renderExercisesGrid();
      try { await enqueueAction('upsert_exercise', JSON.stringify(ex)); } catch (e) { console.warn('upsert_exercise failed', e); }
    }

  // --- Structured data helpers (exercises + sets store) ---
    const EXERCISES_KEY = 'gym-exercises';
    const SETS_KEY = 'gym-sets';

    // Exercises are a global list saved to localStorage so they persist across sessions/devices (and can be synced to the Sheet).
    function loadExercises() {
      try {
        return JSON.parse(localStorage.getItem(EXERCISES_KEY) || '[]');
      } catch (e) {
        return [];
      }
    }

    function saveExercises(arr) {
      localStorage.setItem(EXERCISES_KEY, JSON.stringify(arr || []));
      // Legacy hook: some older UI variants used a <select> for exercises.
      // The app now uses a tile grid, but keep a compatibility helper so
      // calls to `updateExerciseSelect()` don't throw ReferenceError.
      try {
        updateExerciseSelect();
      } catch (e) {
        // no-op ‚Äî if the function isn't defined elsewhere, define and call it.
        // (see implementation further down)
      }
    }

    // Backwards-compatible helper: update any legacy exercise <select> elements
    // and re-render the modern tile grid. Kept small and defensive.
    function updateExerciseSelect() {
      try {
        // Re-render the new grid UI so changes are visible immediately
        if (typeof renderExercisesGrid === 'function') renderExercisesGrid();

        // If a legacy select exists, populate it for compatibility with older code
        const sel = document.getElementById('exerciseSelect');
        if (sel) {
          const exercises = loadExercises();
          sel.innerHTML = '';
          exercises.forEach(ex => {
            const opt = document.createElement('option');
            opt.value = ex.id;
            opt.textContent = ex.name;
            sel.appendChild(opt);
          });
        }
      } catch (e) {
        // ignore errors ‚Äî this is a best-effort compatibility helper
      }
    }

    function loadSets() {
      try {
        return JSON.parse(localStorage.getItem(SETS_KEY) || '[]');
      } catch (e) {
        return [];
      }
    }

    function saveSets(arr) {
      localStorage.setItem(SETS_KEY, JSON.stringify(arr || []));
    }

    // (updateExerciseSelect removed - no longer using select dropdowns)

    function loadStructuredData() {
      // Keep backward compatibility: if STORAGE_KEY contains a sessions-based v2 payload,
      // we won't delete it ‚Äî but the app now prefers the global exercises + sets stores.
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      try {
        return JSON.parse(raw);
      } catch (e) {
        return null;
      }
    }

    function saveStructuredData(obj) {
      // Deprecated for new flow ‚Äî keep for compatibility
      localStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
      flashStatus('Saved ‚úîÔ∏è');
    }

    function getCurrentSession(data) {
      // Sessions are optional in the new model. Return null unless the old schema is present.
      const d = data || loadStructuredData();
      if (!d || !d.sessions || d.sessions.length === 0) return null;
      return d.sessions[d.sessions.length - 1];
    }

    // generate a compact client-side id for sets/exercises to help server-side dedupe and lookup
    function generateId() {
      return Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 9);
    }

    async function newSession() {
      // Sessions are optional; keep behavior for backward compatibility
      const d = loadStructuredData() || { version: 2, sessions: [] };
      const session = { id: Date.now(), date: new Date().toISOString(), notes: '', exercises: [] };
      d.sessions.push(session);
      saveStructuredData(d);
      flashStatus('New session created');
      try { await enqueueAction('new_session', JSON.stringify({ id: session.id, date: session.date })); } catch (e) {}
    }

    // (old addSet function removed - now using simplified tile-based UI)

    async function exportRowsToSheet() {
      // Flatten global sets list into rows for the Sheet. Each set is one row.
      const sets = loadSets();
      const exercises = loadExercises().reduce((m, e) => { m[e.id] = e; return m; }, {});
      const rows = [];
      for (let i = 0; i < sets.length; i++) {
        const set = sets[i];
        const ex = exercises[set.exerciseId] || { name: '' };
        rows.push({
          exerciseId: set.exerciseId,
          exercise: ex.name,
          setId: set.id,
          setIndex: null,
          setTs: set.ts,
          reps: set.reps,
          weight: set.weight,
          notes: set.notes || ''
        });
      }
      if (rows.length === 0) return flashStatus('No structured rows to export', 2000);
      flashStatus('Exporting rows‚Ä¶', 5000);
      try {
        const res = await enqueueAction('export_rows', JSON.stringify({ rows }));
        if (res && res.ok) {
          flashStatus('Exported rows to Sheet ‚úîÔ∏è', 2500);
        } else if (res && res.queued) {
          flashStatus('Export queued for sync ‚úîÔ∏è', 2500);
        } else {
          console.warn('Export rows response', res);
          flashStatus('Export failed (see console)', 4000);
        }
      } catch (e) {
        console.warn(e);
      }
    }

  // --- Render exercises grid on load and after data changes ---
  window.addEventListener('load', () => {
    renderExercisesGrid();
  });

  // legacy token/test debug handlers removed from main UI
    
    
    
    
    
    
    
    
    
    
    
  // --- previous token/test handlers (no visible buttons now) ---
  // kept in case you want to re-enable them later
  // setSheetTokenBtn.addEventListener('click', () => { ... })
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  // ---
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    // clearBtn removed (no longer in UI)

    // --- Service worker registration (helps installability + offline) ---
    // sw.js must be in the same folder as this index.html
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", async () => {
        try {
          const reg = await navigator.serviceWorker.register("./sw.js");
          // Optional: you can show this if you want
          // console.log("Service worker registered:", reg.scope);
        } catch (err) {
          console.warn("Service worker registration failed:", err);
          flashStatus("SW failed to register (check console) ‚ö†Ô∏è", 2000);
        }
      });
    }

    // Tiny debug info to help confirm install / context
    const isStandalone =
      window.matchMedia("(display-mode: standalone)").matches ||
      window.navigator.standalone === true;

    const href = window.location.href;
    pwaInfo.innerHTML = isStandalone
      ? "‚úÖ Running as an installed app (standalone)."
      : `‚ÑπÔ∏è Not installed. To add to your home screen or install, open your browser menu and choose "Install app" / "Add to Home screen".<br/><span class="mono">URL:</span> <code>${href}</code>`;
  </script>

  <!-- Google Identity Services -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <script>
    // --- Logging to Google Sheets (Apps Script) ---
  // Configure these placeholders with your Apps Script web app URL and secret token.
  const SHEETS_WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbwHk6otl1AmaEIBzZnPvfQX9055EOY2t3AnrqFFNpK93axNDtnF6r5AmkjO6XO505M2ew/exec';
  // Removed secret from repo. If your Apps Script now accepts anonymous posts,
  // leave this empty. To use a secret again, set it locally in your browser
  // (e.g. via localStorage) instead of committing it here.
  const SHEETS_SECRET_TOKEN = '';
  const SHEETS_LOCAL_TOKEN_KEY = 'gym-log-sheet-token';

  // --- Google Sign-In (ID token) ---
  // Replace with your web client ID from Google Cloud Console
  const GSI_CLIENT_ID = '724854461776-mvmetnomlehe776c6t64nmr6rgm9uvu7.apps.googleusercontent.com';
  const GSI_ID_TOKEN_KEY = 'gym-gsi-idtoken';

  function parseJwt(token) {
    try {
      const base64Url = token.split('.')[1];
      const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
      const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
      }).join(''));
      return JSON.parse(jsonPayload);
    } catch (e) {
      return null;
    }
  }

  function initGsi() {
    try {
      if (!window.google || !google.accounts || !google.accounts.id) return;
      google.accounts.id.initialize({
        client_id: GSI_CLIENT_ID,
        callback: handleCredentialResponse,
        cancel_on_tap_outside: true
      });
      // Render the standard Google Sign-In button into our container
      const el = document.getElementById('gsiButton');
      if (el) google.accounts.id.renderButton(el, { theme: 'outline', size: 'medium' });
      // If we have a stored token, surface the user immediately
      const existing = localStorage.getItem(GSI_ID_TOKEN_KEY);
      if (existing) {
        const payload = parseJwt(existing);
        updateGsiStatusUI(payload);
        // If we already had a token on load, fetch user data
        (async () => {
          try { await fetchAndSaveExercises(); } catch (e) {}
          try { await fetchAndMergeRecentLogs(); } catch (e) {}
          try { await fetchAndDisplayPlanMetadata(); } catch (e) {}
        })();
      }
    } catch (e) {
      // ignore
    }
  }

  function handleCredentialResponse(resp) {
    if (!resp || !resp.credential) return;
    try {
      localStorage.setItem(GSI_ID_TOKEN_KEY, resp.credential);
      const payload = parseJwt(resp.credential);
      updateGsiStatusUI(payload);
      flashStatus('Signed in ‚úîÔ∏è', 1600);
      // After sign-in, ensure user defaults exist and load exercises + recent logs
      (async () => {
        try {
          // ensure server-side defaults (idempotent)
          await logActionToSheet('ensure_user', JSON.stringify({}));
        } catch (e) {}
        try { await fetchAndSaveExercises(); } catch (e) {}
        try { await fetchAndMergeRecentLogs(); } catch (e) {}
        try { await fetchAndDisplayPlanMetadata(); } catch (e) {}
      })();
    } catch (e) {
      console.warn('GSI handle error', e);
    }
  }

  function updateGsiStatusUI(payload) {
    const s = document.getElementById('gsiStatus');
    const btn = document.getElementById('gsiButton');
    const out = document.getElementById('gsiSignOut');
    if (!s) return;
    if (payload && payload.email) {
      s.textContent = `Signed in as ${payload.email}`;
      if (btn) btn.style.display = 'none';
      if (out) out.style.display = '';
    } else {
      s.textContent = 'Not signed in';
      if (btn) btn.style.display = '';
      if (out) out.style.display = 'none';
    }
  }

  function signOutGsi() {
    try {
      localStorage.removeItem(GSI_ID_TOKEN_KEY);
      // Clear all UI state and user-scoped local data without reloading
      clearAppState();
      updateGsiStatusUI(null);
      if (window.google && google.accounts && google.accounts.id && google.accounts.id.disableAutoSelect) {
        google.accounts.id.disableAutoSelect();
      }
      flashStatus('Signed out', 1200);
    } catch (e) {}
  }

  // Clear user-visible and persisted app state (do not reload page)
  function clearAppState() {
    try {
      // Remove user-specific local stores
      localStorage.removeItem(EXERCISES_KEY);
      localStorage.removeItem(SETS_KEY);
      localStorage.removeItem(ACTION_QUEUE_KEY);
      localStorage.removeItem(LOGGED_SET_IDS_KEY);
      try { localStorage.removeItem(SHEETS_LOCAL_TOKEN_KEY); } catch (e) {}

      // Clear UI: hide plan summary and remove exercise tiles
      const grid = document.getElementById('exercisesGrid');
      if (grid) grid.innerHTML = '';
      const summary = document.getElementById('planSummary');
      if (summary) summary.style.display = 'none';
      const planContent = document.getElementById('planSummaryContent');
      if (planContent) planContent.textContent = '';
      const status = document.getElementById('status');
      if (status) status.textContent = '';

      // Ensure any open modals are closed
      const modal = document.getElementById('exerciseModal');
      if (modal) modal.style.display = 'none';

      // Reset sync UI (if present)
      try { updateSyncStatus(); } catch (e) {}
    } catch (e) {
      // no-op
    }
  }

  function getGsiIdToken() {
    try {
      const token = localStorage.getItem(GSI_ID_TOKEN_KEY);
      if (!token) return null;
      
      // Check if token is expired
      const payload = parseJwt(token);
      if (payload && payload.exp) {
        const nowSec = Math.floor(Date.now() / 1000);
        const expSec = Number(payload.exp);
        if (expSec < nowSec) {
          // Token expired, clear it and prompt re-auth
          console.warn('ID token expired, clearing');
          localStorage.removeItem(GSI_ID_TOKEN_KEY);
          updateGsiStatusUI(null);
          flashStatus('Session expired - please sign in again', 3000);
          return null;
        }
      }
      
      return token;
    } catch (e) { 
      return null; 
    }
  }

  // After sign-in / on load helpers: fetch exercises and recent logs for the signed-in user
  async function fetchAndSaveExercises() {
    try {
      const res = await logActionToSheet('get_exercises', JSON.stringify({}));
      if (res && res.ok && Array.isArray(res.exercises)) {
        // Save exercises with all plan data
        saveExercises(res.exercises);
        // legacy "Exercises loaded" toast removed to reduce noise
        renderExercisesGrid(); // Re-render grid after loading
      }
    } catch (e) {
      console.warn('fetchExercises failed', e);
    }
  }

  async function fetchAndDisplayPlanMetadata() {
    try {
      const res = await logActionToSheet('get_plan_metadata', JSON.stringify({}));
      if (res && res.ok) {
        const summary = document.getElementById('planSummary');
        const content = document.getElementById('planSummaryContent');
        const date = document.getElementById('planSummaryDate');
        
        if (res.globalReasoning) {
          content.textContent = res.globalReasoning;
          if (res.planLastUpdated) {
            const lastUpdated = new Date(res.planLastUpdated);
            const timeAgo = getTimeAgo(lastUpdated);
            date.textContent = `Updated ${timeAgo}`;
          }
          summary.style.display = 'block';
        } else {
          summary.style.display = 'none';
        }
      }
    } catch (e) {
      console.warn('fetchPlanMetadata failed', e);
    }
  }

  function getTimeAgo(date) {
    const seconds = Math.floor((Date.now() - date.getTime()) / 1000);
    if (seconds < 60) return 'just now';
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes}m ago`;
    const hours = Math.floor(minutes / 60);
    if (hours < 24) return `${hours}h ago`;
    const days = Math.floor(hours / 24);
    return `${days}d ago`;
  }

  async function fetchAndMergeRecentLogs(limit = 50) {
    try {
      const res = await logActionToSheet('fetch_recent_logs', JSON.stringify({ limit }));
      if (res && res.ok && Array.isArray(res.rows)) {
        const rows = res.rows;
        // Convert rows to local set objects and merge into local saved sets without duplicating setId
        const existing = loadSets();
        const existingIds = new Set(existing.map(s => s.id));
        const toAdd = [];
        for (const r of rows) {
          const sid = r.setId || generateId();
          if (existingIds.has(sid)) continue;
          const ts = (r.date && new Date(r.date).toISOString()) || new Date().toISOString();
          const setObj = {
            id: sid,
            exerciseId: r.exerciseId || '',
            ts: ts,
            reps: r.reps !== undefined ? r.reps : null,
            weight: r.weight || '',
            duration_s: r.duration_s !== undefined ? r.duration_s : null,
            distance_km: r.distance_km !== undefined ? r.distance_km : null,
            notes: r.notes || ''
          };
          toAdd.push(setObj);
          existingIds.add(sid);
        }
        if (toAdd.length) {
          // prepend so recent items appear first locally
          const merged = toAdd.concat(existing);
          saveSets(merged);
          flashStatus(`${toAdd.length} recent log(s) loaded`, 1800);
        }
      }
    } catch (e) {
      console.warn('fetchRecentLogs failed', e);
    }
  }

    async function logActionToSheet(action, details = '') {
      if (!SHEETS_WEB_APP_URL || SHEETS_WEB_APP_URL.includes('REPLACE_WITH')) return false;
      // Build payload carefully: if `details` is a JSON string or an object
      // that contains fields like `sets` or `rows`, merge those fields into
      // the top-level payload so the Apps Script receives them as top-level keys.
      let payload = { action };
      // attempt to parse details if it's a JSON string
      let parsedDetails = details;
      if (typeof details === 'string') {
        try {
          parsedDetails = JSON.parse(details);
        } catch (e) {
          // leave as string
          parsedDetails = details;
        }
      }
      if (parsedDetails && typeof parsedDetails === 'object' && !Array.isArray(parsedDetails)) {
        // merge keys from parsedDetails into payload (but don't override action or _token)
        for (const k of Object.keys(parsedDetails)) {
          if (k === 'action' || k === '_token') continue;
          payload[k] = parsedDetails[k];
        }
      } else {
        // not an object ‚Äî send as details field
        payload.details = parsedDetails;
      }
      // Include token only when explicitly set in constant or locally in browser storage
      try {
        if (SHEETS_SECRET_TOKEN) payload._token = SHEETS_SECRET_TOKEN;
        const localToken = localStorage.getItem(SHEETS_LOCAL_TOKEN_KEY);
        if (localToken) payload._token = localToken;
        // Include Google ID token if the user signed in via GSI
        const idToken = getGsiIdToken();
        if (idToken) payload._id_token = idToken;
      } catch (e) {
        // ignore localStorage errors (e.g., privacy mode)
      }
      try {
        // Send as plain text (no custom Content-Type) to avoid triggering CORS preflight.
        // Apps Script doPost can read the raw body from e.postData.contents and JSON.parse it.
        const res = await fetch(SHEETS_WEB_APP_URL, {
          method: 'POST',
          body: JSON.stringify(payload),
          // don't set headers here to keep request simple (text/plain) and avoid preflight
        });
        if (!res.ok) {
          // non-2xx (may also be blocked by CORS and thrown as an exception)
          const txt = await res.text().catch(() => '<no body>');
          console.warn('Log failed', res.status, txt);
          return { ok: false, status: res.status, text: txt };
        }
        // Some deployments (if CORS is misconfigured) may not allow reading the response; handle safely
        try {
          const json = await res.json();
          
          // Handle server-side token expiration errors
          if (json && !json.ok && (json.error === 'id_token expired' || json.error?.includes('expired'))) {
            console.warn('Server reported token expired, clearing local token');
            localStorage.removeItem(GSI_ID_TOKEN_KEY);
            updateGsiStatusUI(null);
            flashStatus('Session expired - please sign in again', 3000);
            // Optionally trigger GSI prompt automatically
            if (window.google?.accounts?.id?.prompt) {
              setTimeout(() => google.accounts.id.prompt(), 1000);
            }
          }
          
          return json;
        } catch (e) {
          return { ok: true };
        }
      } catch (err) {
        console.warn('Log error', err);
        return { ok: false, error: String(err) };
      }
    }

    // --- Offline queue & sync helpers ---
    const ACTION_QUEUE_KEY = 'gym-log-queue';
    // Persisted list of set IDs we've confirmed were written to the Sheet. This
    // helps avoid re-sending the same set on reloads or across retries.
    const LOGGED_SET_IDS_KEY = 'gym-logged-ids';
    const syncStatusEl = document.getElementById('syncStatus');

    function loadLoggedSetIds() {
      try {
        return JSON.parse(localStorage.getItem(LOGGED_SET_IDS_KEY) || '[]');
      } catch (e) {
        return [];
      }
    }

    function saveLoggedSetIds(arr) {
      try {
        localStorage.setItem(LOGGED_SET_IDS_KEY, JSON.stringify(Array.from(new Set(arr || []))));
      } catch (e) {}
    }

    function addLoggedSetIds(ids) {
      if (!Array.isArray(ids) || ids.length === 0) return;
      const current = loadLoggedSetIds();
      const merged = Array.from(new Set(current.concat(ids)));
      saveLoggedSetIds(merged);
    }

    function updateSyncStatus() {
      if (!syncStatusEl) return; // indicator removed from DOM; no-op when absent
      try {
        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
        const pending = q.length || 0;
        if (!navigator.onLine) {
          syncStatusEl.textContent = `‚ö†Ô∏è Offline ‚Äî ${pending} pending`;
          syncStatusEl.style.cursor = 'pointer';
        } else if (pending > 0) {
          syncStatusEl.textContent = `üîÅ ${pending} pending`;
          syncStatusEl.style.cursor = 'pointer';
        } else {
          // no "Synced" indicator ‚Äî keep quiet when all clear
          syncStatusEl.textContent = '';
          syncStatusEl.style.cursor = 'default';
        }
      } catch (e) {
        if (syncStatusEl) syncStatusEl.textContent = navigator.onLine ? '‚úÖ Online' : '‚ö†Ô∏è Offline';
      }
    }

    async function enqueueAction(action, details = '') {
      const fingerprint = JSON.stringify({ action, details });
      const item = { action, details, ts: new Date().toISOString(), fingerprint };
      // Try to send immediately when online
      if (navigator.onLine) {
        try {
          const res = await logActionToSheet(action, details);
          if (res && res.ok) {
            // Remove any previously queued items that match this action/details to avoid duplicates
            try {
              const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
              const filtered = q.filter((it) => it.fingerprint !== fingerprint);
              if (filtered.length !== q.length) {
                localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(filtered));
              }
            } catch (e) {
              // ignore
            }
            // If this was a log_efforts action, record the effort ids that the server
            // accepted so we don't re-send them after a reload.
            try {
              if (action === 'log_efforts') {
                // prefer server-reported saved ids when available
                if (res && res.ok && Array.isArray(res.saved)) {
                  const ids = res.saved.map(s => s && s.id).filter(Boolean);
                  if (ids.length) addLoggedSetIds(ids);
                } else {
                  // fallback: read ids from outgoing payload
                  let parsed = details;
                  if (typeof details === 'string') {
                    try { parsed = JSON.parse(details); } catch (e) { parsed = null; }
                  }
                  if (parsed && Array.isArray(parsed.efforts)) {
                    const ids = parsed.efforts.map(s => s && s.id).filter(Boolean);
                    if (ids.length) addLoggedSetIds(ids);
                  }
                }
              }
            } catch (e) {
              // ignore
            }
            updateSyncStatus();
            return { ok: true, sent: true, res };
          }
        } catch (e) {
          // fall through to queueing
        }
      }
          // queue locally
      try {
        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
        // avoid exact-duplicate queue entries (same fingerprint)
        const exists = q.some((it) => it.fingerprint === fingerprint);
        if (!exists) {
          // If this is a log_efforts, avoid queueing it if all effort ids are already recorded
              let shouldQueue = true;
              if (action === 'log_efforts') {
                let parsed = details;
                if (typeof details === 'string') {
                  try { parsed = JSON.parse(details); } catch (e) { parsed = null; }
                }
                if (parsed && Array.isArray(parsed.efforts)) {
                  const logged = new Set(loadLoggedSetIds());
                  const allLogged = parsed.efforts.every(s => s && s.id && logged.has(s.id));
                  if (allLogged) shouldQueue = false;
                }
              }
              if (shouldQueue) q.push(item);
        }
        localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(q));
        updateSyncStatus();
        return { ok: false, queued: true };
      } catch (e) {
        console.warn('Queue error', e);
        return { ok: false, error: String(e) };
      }
    }

    async function flushQueue() {
      try {
        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
        if (!q || q.length === 0) return updateSyncStatus();
        updateSyncStatus();
        const remaining = [];
        const sentFingerprints = [];
        for (const item of q) {
          try {
            const res = await logActionToSheet(item.action, item.details);
            if (res && res.ok) {
                  // mark this fingerprint as successfully sent
                  sentFingerprints.push(item.fingerprint);
                  // record any set ids that were sent so we avoid re-sending them later
                  try {
                    // Prefer server-reported saved ids
                    if (res && res.ok && Array.isArray(res.saved)) {
                      const ids = res.saved.map(s => s && s.id).filter(Boolean);
                      if (ids.length) addLoggedSetIds(ids);
                    } else if (item.action === 'log_efforts') {
                      let parsed = item.details;
                      if (typeof item.details === 'string') {
                        try { parsed = JSON.parse(item.details); } catch (e) { parsed = null; }
                      }
                      if (parsed && Array.isArray(parsed.efforts)) {
                        const ids = parsed.efforts.map(s => s && s.id).filter(Boolean);
                        if (ids.length) addLoggedSetIds(ids);
                      }
                    }
                  } catch (e) {}
            } else {
              remaining.push(item);
            }
          } catch (e) {
            remaining.push(item);
          }
        }
        // To avoid races where the stored queue changed while we were sending,
        // read the latest queue and filter out any items we know were sent.
        try {
          let current = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
          if (sentFingerprints.length > 0 && Array.isArray(current) && current.length > 0) {
            current = current.filter((it) => !sentFingerprints.includes(it.fingerprint));
            // Remove any items from 'remaining' whose sets are already recorded on the client
            try {
              const loggedIds = new Set(loadLoggedSetIds());
              const filteredRemaining = (remaining || []).filter(r => {
                if (!r || !r.action) return true;
                if (r.action !== 'log_efforts') return true;
                let parsed = r.details;
                if (typeof r.details === 'string') {
                  try { parsed = JSON.parse(r.details); } catch (e) { parsed = null; }
                }
                if (!parsed || !Array.isArray(parsed.efforts)) return true;
                // if ALL effort ids are already logged, drop this queued item
                const allLogged = parsed.efforts.every(s => s && s.id && loggedIds.has(s.id));
                return !allLogged;
              });
              // merge any items that failed during this run (filteredRemaining) ensuring order is preserved
              const merged = current.concat(filteredRemaining.filter(r => !current.some(c => c.fingerprint === r.fingerprint)));
              localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(merged));
            } catch (e) {
              const remainingFingerprints = new Set((remaining || []).map(r => r.fingerprint));
              const merged = current.concat(remaining.filter(r => !current.some(c => c.fingerprint === r.fingerprint)));
              localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(merged));
            }
          } else {
            localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(remaining));
          }
        } catch (e) {
          // fallback to the conservative write
          localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(remaining));
        }
        updateSyncStatus();
        return { ok: true, remaining: remaining.length };
      } catch (e) {
        console.warn('Flush queue error', e);
        updateSyncStatus();
        return { ok: false, error: String(e) };
      }
    }

    // --- Queue viewer & management UI ---
  const queueListEl = document.getElementById('queueList');
  const retryQueueBtn = document.getElementById('retryQueue');
  const clearQueueBtn = document.getElementById('clearQueue');

    function renderQueue() {
      try {
        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
        if (!queueListEl) return;
        queueListEl.innerHTML = '';
        if (!q || q.length === 0) {
          queueListEl.textContent = 'No pending actions';
          return;
        }
        q.forEach((item, idx) => {
          const el = document.createElement('div');
          el.style.display = 'flex';
          el.style.justifyContent = 'space-between';
          el.style.alignItems = 'center';
          el.style.padding = '6px 4px';
          el.style.borderBottom = '1px solid rgba(255,255,255,0.03)';
          const left = document.createElement('div');
          left.style.flex = '1';
          left.innerHTML = `<div><strong>${item.action}</strong> <span style="opacity:0.7">${new Date(item.ts).toLocaleString()}</span></div><div style="opacity:0.85">${String(item.details).slice(0,200)}</div>`;
          const right = document.createElement('div');
          right.style.display = 'flex';
          right.style.gap = '6px';
          const retryBtn = document.createElement('button');
          retryBtn.textContent = 'Retry';
          retryBtn.className = 'secondary';
          retryBtn.addEventListener('click', async () => {
            retryBtn.disabled = true;
            try {
              const res = await logActionToSheet(item.action, item.details);
              if (res && res.ok) {
                // remove any queued items matching this fingerprint (safer than splice-by-index)
                try {
                  const q2 = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
                  const filtered = q2.filter((it) => it.fingerprint !== item.fingerprint);
                  localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(filtered));
                } catch (e) {
                  // ignore
                }
                // record logged effort ids for log_efforts
                try {
                  if (item.action === 'log_efforts') {
                    // prefer server-side response if available
                    if (res && res.ok && Array.isArray(res.saved)) {
                      const ids = res.saved.map(s => s && s.id).filter(Boolean);
                      if (ids.length) addLoggedSetIds(ids);
                    } else {
                      let parsed = item.details;
                      if (typeof item.details === 'string') {
                        try { parsed = JSON.parse(item.details); } catch (e) { parsed = null; }
                      }
                      if (parsed && Array.isArray(parsed.efforts)) {
                        const ids = parsed.efforts.map(s => s && s.id).filter(Boolean);
                        if (ids.length) addLoggedSetIds(ids);
                      }
                    }
                  }
                } catch (e) {}
                renderQueue();
                updateSyncStatus();
                flashStatus('Retried and removed ‚úîÔ∏è');
              } else {
                flashStatus('Retry failed (see console)');
                console.warn('Retry response', res);
              }
            } catch (e) {
              console.warn('Retry error', e);
              flashStatus('Retry failed');
            }
            retryBtn.disabled = false;
          });
          const delBtn = document.createElement('button');
          delBtn.textContent = 'Remove';
          delBtn.className = 'secondary';
          delBtn.addEventListener('click', () => {
            try {
              const q2 = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
              const filtered = q2.filter((it) => it.fingerprint !== item.fingerprint);
              localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(filtered));
            } catch (e) {
              // ignore
            }
            renderQueue();
            updateSyncStatus();
            flashStatus('Removed from queue');
          });
          right.appendChild(retryBtn);
          right.appendChild(delBtn);
          el.appendChild(left);
          el.appendChild(right);
          queueListEl.appendChild(el);
        });
      } catch (e) {
        console.warn('Render queue error', e);
      }
    }

    retryQueueBtn.addEventListener('click', async () => {
      retryQueueBtn.disabled = true;
      flashStatus('Retrying queue‚Ä¶', 2000);
      await flushQueue();
      renderQueue();
      retryQueueBtn.disabled = false;
    });

    clearQueueBtn.addEventListener('click', () => {
      localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify([]));
      renderQueue();
      updateSyncStatus();
      flashStatus('Queue cleared');
    });

    // Download button removed ‚Äî kept the code previously for debugging only.

    // render initially
    setTimeout(renderQueue, 800);

    // Attempt to flush when connection returns
    window.addEventListener('online', () => {
      updateSyncStatus();
      setTimeout(flushQueue, 800);
    });
    window.addEventListener('offline', updateSyncStatus);
    // Toggle the pending-queue panel when clicking the compact syncStatus
    try {
      const syncEl = document.getElementById('syncStatus');
      const panel = document.getElementById('queuePanel');
      if (syncEl && panel) {
        syncEl.addEventListener('click', () => {
          // only toggle when there might be something to show
          const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]') || [];
          if (!navigator.onLine && q.length === 0) return; // nothing to show
          panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
          if (panel.style.display === 'block') renderQueue();
        });
      }
    } catch (e) {}
    // Try flushing shortly after load
    window.addEventListener('load', () => {
      setTimeout(() => {
        updateSyncStatus();
        flushQueue();
      }, 1200);
    });
    // Initialize Google Sign-In when page loads
    window.addEventListener('load', initGsi);

    // Wire sign-out button
    try {
      const gsiOut = document.getElementById('gsiSignOut');
      if (gsiOut) gsiOut.addEventListener('click', signOutGsi);
    } catch (e) {}

    // Wire Generate All Plans button
    try {
      const generateAllBtn = document.getElementById('generateAllPlansBtn');
      if (generateAllBtn) {
        generateAllBtn.addEventListener('click', async () => {
          generateAllBtn.disabled = true;
          generateAllBtn.textContent = '‚è≥ Analyzing your workouts...';
          
          try {
            const res = await logActionToSheet('generate_all_plans', JSON.stringify({ autoSave: true }));
            
            if (res && res.ok && res.plans) {
              // Update all exercises with their new plans
              const exercises = loadExercises();
              let updatedCount = 0;
              
              exercises.forEach(ex => {
                if (res.plans[ex.id]) {
                  ex.plan = res.plans[ex.id].plan;
                  ex.planReasoning = res.plans[ex.id].reasoning;
                  updatedCount++;
                }
              });
              
              if (updatedCount > 0) {
                saveExercises(exercises);
                renderExercisesGrid(); // Refresh tiles
                
                // Refresh plan metadata display
                try { await fetchAndDisplayPlanMetadata(); } catch (e) {}
                
                // Show global reasoning
                const globalMsg = res.globalReasoning || `Plans generated for ${updatedCount} exercises`;
                flashStatus(`‚ú® ${globalMsg}`, 4000);
              } else {
                flashStatus('No exercises to plan', 2000);
              }
            } else if (res && res.cooldown) {
              // 24h cooldown error
              flashStatus(`‚è±Ô∏è ${res.error}`, 4000);
            } else {
              const errMsg = res?.error || 'Plan generation failed';
              flashStatus(`‚ö†Ô∏è ${errMsg}`, 3000);
              console.warn('generate_all_plans response:', res);
            }
          } catch (e) {
            flashStatus('Error generating plans', 2500);
            console.error('generate_all_plans error:', e);
          }
          
          generateAllBtn.disabled = false;
          generateAllBtn.textContent = '‚ú® Generate AI Training Plan';
        });
      }
    } catch (e) {
      console.warn('Failed to wire generateAllPlansBtn', e);
    }
  </script>
</body>
</html>
