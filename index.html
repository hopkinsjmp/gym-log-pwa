<!DOCTYPE html><!DOCTYPE html>

<html lang="en"><html lang="en">

<head><head>

  <meta charset="utf-8" />  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Gym Log</title>

  <meta name="theme-color" content="#111827" />  <title>Gym Log</title>

  <link rel="manifest" href="./manifest.json" />

  <meta name="apple-mobile-web-app-capable" content="yes" />  <!-- PWA basics -->

  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />  <meta name="theme-color" content="#111827" />

  <meta name="apple-mobile-web-app-title" content="GymLog" />  <link rel="manifest" href="./manifest.json" />



  <style>  <!-- Nice-to-haves (Android/Chrome + iOS-ish) -->

    body {  <meta name="apple-mobile-web-app-capable" content="yes" />

      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

      margin: 0;  <meta name="apple-mobile-web-app-title" content="GymLog" />

      padding: 16px;

      background: #111827;  <!-- Optional: you can add an iOS icon later if you want -->

      color: #f9fafb;  <!-- <link rel="apple-touch-icon" href="./icon-192.png" /> -->

    }

  <style>

    h1 {    body {

      margin: 0 0 12px;      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;

      font-size: 1.4rem;      margin: 0;

    }      padding: 16px;

      background: #111827;

    .hint {      color: #f9fafb;

      margin: 0 0 12px;    }

      opacity: 0.75;

      font-size: 0.95rem;    h1 {

      line-height: 1.3;      margin: 0 0 12px;

    }      font-size: 1.4rem;

    }

    .row {

      display: flex;    .hint {

      gap: 10px;      margin: 0 0 12px;

      margin-top: 12px;      opacity: 0.75;

      align-items: center;      font-size: 0.95rem;

      flex-wrap: wrap;      line-height: 1.3;

    }    }



    button {    textarea {

      padding: 12px 16px;      width: 100%;

      font-size: 16px;      min-height: 240px;

      border-radius: 10px;      padding: 12px;

      border: none;      font-size: 16px;

      background: #7c3aed;      border-radius: 10px;

      color: white;      border: 1px solid rgba(255,255,255,0.12);

      font-weight: 600;      background: rgba(255,255,255,0.06);

      cursor: pointer;      color: #f9fafb;

    }      outline: none;

      resize: vertical;

    button.secondary {      box-sizing: border-box;

      background: rgba(255,255,255,0.12);    }

      color: #f9fafb;

    }    textarea:focus {

      border-color: rgba(124, 58, 237, 0.7);

    button:disabled {      box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.25);

      opacity: 0.5;    }

      cursor: not-allowed;

    }    .row {

      display: flex;

    .status {      gap: 10px;

      font-size: 0.95rem;      margin-top: 12px;

      opacity: 0.85;      align-items: center;

      min-height: 1.2em;      flex-wrap: wrap;

    }    }



    .tiny {    button {

      font-size: 0.85rem;      padding: 12px 16px;

      opacity: 0.75;      font-size: 16px;

      margin-top: 10px;      border-radius: 10px;

    }      border: none;

      background: #7c3aed;

    input, select {      color: white;

      padding: 8px;      font-weight: 600;

      border-radius: 8px;      cursor: pointer;

      background: rgba(255,255,255,0.04);    }

      color: #f9fafb;

      border: 1px solid rgba(255,255,255,0.06);    button.secondary {

      font-size: 14px;      background: rgba(255,255,255,0.12);

    }      color: #f9fafb;

    }

    .mono {

      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;    .status {

    }      font-size: 0.95rem;

  </style>      opacity: 0.85;

</head>      min-height: 1.2em;

    }

<body>

  <h1>üèãÔ∏è Gym Log</h1>    .tiny {

  <p class="hint">Quick logging for strength training and cardio. All workouts sync to Google Sheets.</p>      font-size: 0.85rem;

      opacity: 0.75;

  <div class="row">      margin-top: 10px;

    <button id="logSet" type="button">Log Set</button>      line-height: 1.35;

    <button id="logRun" type="button">Log Run</button>    }

    <button id="addExercise" class="secondary" type="button">Add Exercise</button>

  </div>    code {

      background: rgba(255,255,255,0.08);

  <div class="status" id="status" style="margin-top:8px;"></div>      padding: 2px 6px;

  <div class="status" id="syncStatus" style="margin-top:6px; font-size:0.9rem; opacity:0.9"></div>      border-radius: 6px;

    }

  <!-- Pending actions queue panel -->

  <div id="queuePanel" style="margin-top:16px; padding:10px; border-radius:8px; background:rgba(255,255,255,0.02);">    .mono {

    <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;

      <div style="font-weight:700">Pending sync</div>    }

      <div style="display:flex; gap:8px;">  </style>

        <button id="retryQueue" class="secondary" type="button">Retry all</button></head>

        <button id="downloadQueue" class="secondary" type="button">Download</button>

        <button id="clearQueue" class="secondary" type="button">Clear</button><body>

      </div>  <h1>üèãÔ∏è Gym Log</h1>

    </div>  <p class="hint">Quick logging for strength training and cardio. All workouts sync to Google Sheets.</p>

    <div id="queueList" style="margin-top:8px; max-height:180px; overflow:auto; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; font-size:13px;"></div>

  </div>  <div class="row">

    <button id="logSet" type="button">Log Set</button>

  <div class="tiny" id="pwaInfo"></div>    <button id="logRun" type="button">Log Run</button>

    <button id="addExercise" class="secondary" type="button">Add Exercise</button>

  <!-- Add-Set modal -->  </div>

  <div id="addSetModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); align-items:center; justify-content:center; z-index:9999;">

    <div style="background:#0b1220; padding:16px; border-radius:12px; width:92%; max-width:420px; box-shadow:0 10px 30px rgba(0,0,0,0.6); color:#f9fafb;">  <div class="status" id="status" style="margin-top:8px;"></div>

      <h3 style="margin:0 0 8px; font-size:1.1rem;">Log Set</h3>  <div class="status" id="syncStatus" style="margin-top:6px; font-size:0.9rem; opacity:0.9"></div>

      <div style="display:flex; gap:8px; flex-direction:column;">

        <label class="mono" style="font-size:0.9rem; opacity:0.9">Exercise</label>  <!-- Pending actions queue panel -->

        <select id="modalExerciseSelect" style="padding:8px; border-radius:8px;">  <div id="queuePanel" style="margin-top:16px; padding:10px; border-radius:8px; background:rgba(255,255,255,0.02);">

          <option value="__new__">-- New exercise --</option>    <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">

        </select>      <div style="font-weight:700">Pending sync</div>

        <input id="modalExerciseNew" placeholder="If new: name" style="padding:8px; border-radius:8px; display:none;" />      <div style="display:flex; gap:8px;">

        <button id="retryQueue" class="secondary" type="button">Retry all</button>

        <div style="display:flex; gap:8px;">        <button id="downloadQueue" class="secondary" type="button">Download</button>

          <div style="flex:1">        <button id="clearQueue" class="secondary" type="button">Clear</button>

            <label class="mono" style="font-size:0.9rem; opacity:0.9">Sets</label>      </div>

            <input id="modalSets" type="number" min="1" value="3" style="width:100%; padding:8px; border-radius:8px;" />    </div>

          </div>    <div id="queueList" style="margin-top:8px; max-height:180px; overflow:auto; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; font-size:13px;"></div>

          <div style="flex:1">  </div>

            <label class="mono" style="font-size:0.9rem; opacity:0.9">Reps</label>

            <input id="modalReps" type="number" min="0" value="8" style="width:100%; padding:8px; border-radius:8px;" />  <div class="tiny" id="pwaInfo"></div>

          </div>

        </div>  <!-- Add-Set modal -->

  <div id="addSetModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); align-items:center; justify-content:center; z-index:9999;">

        <div style="display:flex; gap:8px;">    <div style="background:#0b1220; padding:16px; border-radius:12px; width:92%; max-width:420px; box-shadow:0 10px 30px rgba(0,0,0,0.6); color:#f9fafb;">

          <div style="flex:1">      <h3 style="margin:0 0 8px; font-size:1.1rem;">Add Set(s)</h3>

            <label class="mono" style="font-size:0.9rem; opacity:0.9">Weight</label>      <div style="display:flex; gap:8px; flex-direction:column;">

            <input id="modalWeight" type="number" step="0.5" style="width:100%; padding:8px; border-radius:8px;" />        <label class="mono" style="font-size:0.9rem; opacity:0.9">Exercise</label>

          </div>        <select id="modalExerciseSelect" style="padding:8px; border-radius:8px; background:rgba(255,255,255,0.04); color:#f9fafb; border:1px solid rgba(255,255,255,0.06)">

          <div style="width:110px">          <option value="__new__">-- New exercise --</option>

            <label class="mono" style="font-size:0.9rem; opacity:0.9">Unit</label>        </select>

            <select id="modalUnit" style="width:100%; padding:8px; border-radius:8px;">        <input id="modalExerciseNew" placeholder="If new: name" style="padding:8px; border-radius:8px; background:rgba(255,255,255,0.03); color:#f9fafb; border:1px solid rgba(255,255,255,0.06); display:none;" />

              <option value="kg">kg</option>

              <option value="lb">lb</option>        <div style="display:flex; gap:8px;">

              <option value="">(none)</option>          <div style="flex:1">

            </select>            <label class="mono" style="font-size:0.9rem; opacity:0.9">Sets</label>

          </div>            <input id="modalSets" type="number" min="1" value="3" style="width:100%; padding:8px; border-radius:8px;" />

        </div>          </div>

          <div style="flex:1">

        <!-- Cardio fields (hidden for strength mode) -->            <label class="mono" style="font-size:0.9rem; opacity:0.9">Reps</label>

        <div id="modalCardioFields" style="display:none;">            <input id="modalReps" type="number" min="0" value="8" style="width:100%; padding:8px; border-radius:8px;" />

          <div style="display:flex; gap:8px;">          </div>

            <div style="flex:1">        </div>

              <label class="mono" style="font-size:0.9rem; opacity:0.9">Duration (s)</label>

              <input id="modalDuration" type="number" min="0" placeholder="seconds" style="width:100%; padding:8px; border-radius:8px;" />        <div style="display:flex; gap:8px;">

            </div>          <div style="flex:1">

            <div style="width:120px">            <label class="mono" style="font-size:0.9rem; opacity:0.9">Weight</label>

              <label class="mono" style="font-size:0.9rem; opacity:0.9">Distance (km)</label>            <input id="modalWeight" type="number" step="0.5" style="width:100%; padding:8px; border-radius:8px;" />

              <input id="modalDistance" type="number" step="0.01" placeholder="km" style="width:100%; padding:8px; border-radius:8px;" />          </div>

            </div>          <div style="width:110px">

          </div>            <label class="mono" style="font-size:0.9rem; opacity:0.9">Unit</label>

        </div>            <select id="modalUnit" style="width:100%; padding:8px; border-radius:8px;">

              <option value="kg">kg</option>

        <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:8px;">              <option value="lb">lb</option>

          <button id="modalCancel" class="secondary" type="button">Cancel</button>              <option value="">(none)</option>

          <button id="modalAdd" type="button">Add</button>            </select>

        </div>          </div>

      </div>        </div>

    </div>

  </div>        <!-- Cardio fields (hidden for strength mode) -->

        <div id="modalCardioFields" style="display:none;">

  <script>          <div style="display:flex; gap:8px;">

    const statusEl = document.getElementById("status");            <div style="flex:1">

    const pwaInfo = document.getElementById("pwaInfo");              <label class="mono" style="font-size:0.9rem; opacity:0.9">Duration (s)</label>

    const logSetBtn = document.getElementById('logSet');              <input id="modalDuration" type="number" min="0" placeholder="seconds" style="width:100%; padding:8px; border-radius:8px;" />

    const logRunBtn = document.getElementById('logRun');            </div>

    const addExerciseBtn = document.getElementById('addExercise');            <div style="width:120px">

              <label class="mono" style="font-size:0.9rem; opacity:0.9">Distance (km)</label>

    function flashStatus(msg, ms = 1500) {              <input id="modalDistance" type="number" step="0.01" placeholder="km" style="width:100%; padding:8px; border-radius:8px;" />

      statusEl.textContent = msg;            </div>

      window.clearTimeout(flashStatus._t);          </div>

      flashStatus._t = window.setTimeout(() => (statusEl.textContent = ""), ms);        </div>

    }

        <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:8px;">

    // --- Exercises and sets store ---          <button id="modalCancel" class="secondary" type="button">Cancel</button>

    const EXERCISES_KEY = 'gym-exercises';          <button id="modalAdd" type="button">Add</button>

    const SETS_KEY = 'gym-sets';        </div>

      </div>

    function loadExercises() {    </div>

      try {  </div>

        return JSON.parse(localStorage.getItem(EXERCISES_KEY) || '[]');

      } catch (e) {  <script>

        return [];    const statusEl = document.getElementById("status");

      }    const pwaInfo = document.getElementById("pwaInfo");

    }    const logSetBtn = document.getElementById('logSet');

    const logRunBtn = document.getElementById('logRun');

    function saveExercises(arr) {    const addExerciseBtn = document.getElementById('addExercise');

      localStorage.setItem(EXERCISES_KEY, JSON.stringify(arr || []));

      updateExerciseSelect();    function flashStatus(msg, ms = 1500) {

    }      statusEl.textContent = msg;

      window.clearTimeout(flashStatus._t);

    function loadSets() {      flashStatus._t = window.setTimeout(() => (statusEl.textContent = ""), ms);

      try {    }

        return JSON.parse(localStorage.getItem(SETS_KEY) || '[]');

      } catch (e) {    // --- Exercises and sets store ---

        return [];

      }    const EXERCISES_KEY = 'gym-exercises';

    }    const SETS_KEY = 'gym-sets';



    function saveSets(arr) {    // Exercises are a global list saved to localStorage so they persist across sessions/devices (and can be synced to the Sheet).

      localStorage.setItem(SETS_KEY, JSON.stringify(arr || []));    function loadExercises() {

    }      try {

        return JSON.parse(localStorage.getItem(EXERCISES_KEY) || '[]');

    function updateExerciseSelect() {      } catch (e) {

      const select = document.getElementById('modalExerciseSelect');        return [];

      const exercises = loadExercises();      }

      const current = select && select.value;    }

      if (!select) return;

      select.innerHTML = '<option value="__new__">-- New exercise --</option>';    function saveExercises(arr) {

      for (const ex of exercises) {      localStorage.setItem(EXERCISES_KEY, JSON.stringify(arr || []));

        const opt = document.createElement('option');      updateExerciseSelect();

        opt.value = String(ex.id);    }

        opt.textContent = ex.name;

        select.appendChild(opt);    function loadSets() {

      }      try {

      if (current) select.value = current;        return JSON.parse(localStorage.getItem(SETS_KEY) || '[]');

    }      } catch (e) {

        return [];

    function generateId() {      }

      return Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 9);    }

    }

    function saveSets(arr) {

    async function addExercise() {      localStorage.setItem(SETS_KEY, JSON.stringify(arr || []));

      const name = prompt('Exercise name (e.g. Bench Press)');    }

      if (!name) return flashStatus('Cancelled', 1200);

      const exercises = loadExercises();    function updateExerciseSelect() {

      const ex = { id: generateId(), name: name.trim(), notes: '' };      const select = document.getElementById('modalExerciseSelect');

      exercises.push(ex);      const exercises = loadExercises();

      saveExercises(exercises);      // keep the default new option

      flashStatus('Exercise added');      const current = select && select.value;

      try { await enqueueAction('upsert_exercise', JSON.stringify(ex)); } catch (e) {}      if (!select) return;

    }      select.innerHTML = '<option value="__new__">-- New exercise --</option>';

      for (const ex of exercises) {

    async function logSet(mode = 'strength') {        const opt = document.createElement('option');

      const select = document.getElementById('modalExerciseSelect');        opt.value = String(ex.id);

      const newInput = document.getElementById('modalExerciseNew');        opt.textContent = ex.name;

      const setsInput = document.getElementById('modalSets');        select.appendChild(opt);

      const repsInput = document.getElementById('modalReps');      }

      const weightInput = document.getElementById('modalWeight');      // try to reselect previous value

      const unitSelect = document.getElementById('modalUnit');      if (current) select.value = current;

      const cardioFields = document.getElementById('modalCardioFields');    }

      const durationInput = document.getElementById('modalDuration');

      const distanceInput = document.getElementById('modalDistance');    // generate a compact client-side id for sets/exercises to help server-side dedupe and lookup

      const modal = document.getElementById('addSetModal');    function generateId() {

      return Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 9);

      updateExerciseSelect();    }

      const exercises = loadExercises();

      if (exercises && exercises.length) {    async function addExercise() {

        select.value = String(exercises[exercises.length - 1].id);      // Add exercise to global exercises list so it's available across sessions/devices

        newInput.style.display = 'none';      const name = prompt('Exercise name (e.g. Bench Press)');

      } else {      if (!name) return flashStatus('Cancelled', 1200);

        select.value = '__new__';      const exercises = loadExercises();

        newInput.style.display = '';      const ex = { id: generateId(), name: name.trim(), notes: '' };

      }      exercises.push(ex);

      saveExercises(exercises);

      setsInput.value = 3;      flashStatus('Exercise added');

      repsInput.value = 8;      try { await enqueueAction('upsert_exercise', JSON.stringify(ex)); } catch (e) {}

      weightInput.value = '';    }

      unitSelect.value = 'kg';

      durationInput.value = '';    async function logSet(mode = 'strength') {

      distanceInput.value = '';      // Open modal UI for logging sets (prefill exercises)



      const header = modal.querySelector('h3');      const select = document.getElementById('modalExerciseSelect');

      header.textContent = mode === 'cardio' ? 'Log Run' : 'Log Set';      const newInput = document.getElementById('modalExerciseNew');

      modal.style.display = 'flex';        const setsInput = document.getElementById('modalSets');

      const repsInput = document.getElementById('modalReps');

      if (mode === 'cardio') {      const weightInput = document.getElementById('modalWeight');

        repsInput.parentElement.style.display = 'none';      const unitSelect = document.getElementById('modalUnit');

        weightInput.parentElement.parentElement.style.display = 'none';      const cardioFields = document.getElementById('modalCardioFields');

        cardioFields.style.display = '';      const durationInput = document.getElementById('modalDuration');

        setsInput.value = 1;      const distanceInput = document.getElementById('modalDistance');

      } else {      const modal = document.getElementById('addSetModal');

        repsInput.parentElement.style.display = '';

        weightInput.parentElement.parentElement.style.display = '';      // populate exercise list from global exercises store

        cardioFields.style.display = 'none';      updateExerciseSelect();

      }      const exercises = loadExercises();

      if (exercises && exercises.length) {

      function onSelectChange() {        select.value = String(exercises[exercises.length - 1].id);

        if (select.value === '__new__') newInput.style.display = '';        newInput.style.display = 'none';

        else newInput.style.display = 'none';      } else {

      }        select.value = '__new__';

        newInput.style.display = '';

      function closeModal() {      }

        modal.style.display = 'none';

        select.removeEventListener('change', onSelectChange);  // preset values (strength defaults)

        cancelBtn.removeEventListener('click', onCancel);  setsInput.value = 3;

        addBtn.removeEventListener('click', onAdd);  repsInput.value = 8;

      }  weightInput.value = '';

  unitSelect.value = 'kg';

      function onCancel() {  durationInput.value = '';

        closeModal();  distanceInput.value = '';

        flashStatus('Cancelled', 900);

      }  // show modal

  const header = modal.querySelector('h3');

      async function onAdd() {  header.textContent = mode === 'cardio' ? 'Log Run' : 'Log Set(s)';

        const setsCount = Math.max(1, Number(setsInput.value) || 1);  modal.style.display = 'flex';

        const repsVal = repsInput.value === '' ? null : Number(repsInput.value);      // adjust fields based on mode

        const weightVal = weightInput.value === '' ? '' : String(weightInput.value) + (unitSelect.value ? unitSelect.value : '');      if (mode === 'cardio') {

        const durationVal = durationInput.value === '' ? null : Number(durationInput.value);        // show cardio inputs, hide strength inputs

        const distanceVal = distanceInput.value === '' ? null : Number(distanceInput.value);        repsInput.parentElement.style.display = 'none';

        let exObj = null;        weightInput.parentElement.parentElement.style.display = 'none';

        if (select.value === '__new__') {        cardioFields.style.display = '';

          const name = newInput.value && newInput.value.trim();        setsInput.value = 1; // usually single entry for cardio

          if (!name) return flashStatus('Enter exercise name', 1500);      } else {

          exObj = { id: generateId(), name: name, notes: '' };        repsInput.parentElement.style.display = '';

          const exercises = loadExercises();        weightInput.parentElement.parentElement.style.display = '';

          exercises.push(exObj);        cardioFields.style.display = 'none';

          saveExercises(exercises);      }

        } else {

          const exercises = loadExercises();      // handlers

          exObj = exercises.find(e => String(e.id) === String(select.value));      function onSelectChange() {

          if (!exObj) {        if (select.value === '__new__') newInput.style.display = '';

            flashStatus('Exercise not found', 1500);        else newInput.style.display = 'none';

            return;      }

          }

        }      function closeModal() {

        modal.style.display = 'none';

        const sets = loadSets();        select.removeEventListener('change', onSelectChange);

        const createdSets = [];        cancelBtn.removeEventListener('click', onCancel);

        for (let i = 0; i < setsCount; i++) {        addBtn.removeEventListener('click', onAdd);

          const ts = new Date(Date.now() + i * 1000).toISOString();      }

          const sid = generateId();

          let setObj;      function onCancel() {

          if (mode === 'cardio') {        closeModal();

            setObj = { id: sid, exerciseId: exObj.id, exercise: exObj.name, ts, duration_s: durationVal, distance_km: distanceVal };        flashStatus('Cancelled', 900);

          } else {      }

            setObj = { id: sid, exerciseId: exObj.id, exercise: exObj.name, ts, reps: repsVal, weight: weightVal };

          }      async function onAdd() {

          sets.push(setObj);        const setsCount = Math.max(1, Number(setsInput.value) || 1);

          createdSets.push(setObj);        const repsVal = repsInput.value === '' ? null : Number(repsInput.value);

        }        const weightVal = weightInput.value === '' ? '' : String(weightInput.value) + (unitSelect.value ? unitSelect.value : '');

        saveSets(sets);        const durationVal = durationInput.value === '' ? null : Number(durationInput.value);

        closeModal();        const distanceVal = distanceInput.value === '' ? null : Number(distanceInput.value);

        flashStatus(`${setsCount} set(s) logged`);        let exObj = null;

        try {        if (select.value === '__new__') {

          await enqueueAction('log_set', JSON.stringify({ exerciseId: exObj.id, exercise: exObj.name, sets: createdSets, type: mode }));          const name = newInput.value && newInput.value.trim();

        } catch (e) {}          if (!name) return flashStatus('Enter exercise name', 1500);

      }          exObj = { id: Date.now(), name: name, notes: '' };

          const exercises = loadExercises();

      select.addEventListener('change', onSelectChange);          exercises.push(exObj);

      const cancelBtn = document.getElementById('modalCancel');          saveExercises(exercises);

      const addBtn = document.getElementById('modalAdd');        } else {

      cancelBtn.addEventListener('click', onCancel);          const exercises = loadExercises();

      addBtn.addEventListener('click', onAdd);          exObj = exercises.find(e => String(e.id) === String(select.value));

    }          if (!exObj) {

            flashStatus('Exercise not found', 1500);

    logSetBtn.addEventListener('click', () => logSet('strength'));            return;

    logRunBtn.addEventListener('click', () => logSet('cardio'));          }

    addExerciseBtn.addEventListener('click', () => addExercise());        }



    // --- Service worker registration ---        // Add sets with slightly different timestamps to the global sets store

    if ("serviceWorker" in navigator) {        const sets = loadSets();

      window.addEventListener("load", async () => {        const createdSets = [];

        try {        for (let i = 0; i < setsCount; i++) {

          await navigator.serviceWorker.register("./sw.js");          const ts = new Date(Date.now() + i * 1000).toISOString();

        } catch (err) {          const sid = generateId();

          console.warn("Service worker registration failed:", err);          let setObj;

        }          if (mode === 'cardio') {

      });            setObj = { id: sid, exerciseId: exObj.id, exercise: exObj.name, ts, duration_s: durationVal, distance_km: distanceVal };

    }          } else {

            setObj = { id: sid, exerciseId: exObj.id, exercise: exObj.name, ts, reps: repsVal, weight: weightVal };

    const isStandalone = window.matchMedia("(display-mode: standalone)").matches || window.navigator.standalone === true;          }

    pwaInfo.innerHTML = isStandalone ? "‚úÖ Running as installed PWA" : `‚ÑπÔ∏è Install: Chrome menu ‚ãÆ ‚Üí <b>Install app</b>`;          sets.push(setObj);

  </script>          createdSets.push(setObj);

        }

  <script>        saveSets(sets);

    // --- Google Sheets sync ---        closeModal();

    const SHEETS_WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbwHk6otl1AmaEIBzZnPvfQX9055EOY2t3AnrqFFNpK93axNDtnF6r5AmkjO6XO505M2ew/exec';        flashStatus(`${setsCount} set(s) logged`);

    const SHEETS_SECRET_TOKEN = '';        try {

    const SHEETS_LOCAL_TOKEN_KEY = 'gym-log-sheet-token';          // send the full created sets payload so server/sheet can record client ids and full details

          await enqueueAction('log_set', JSON.stringify({ exerciseId: exObj.id, exercise: exObj.name, sets: createdSets, type: mode }));

    async function logActionToSheet(action, details = '') {        } catch (e) {}

      if (!SHEETS_WEB_APP_URL || SHEETS_WEB_APP_URL.includes('REPLACE_WITH')) return false;      }

      let payload = { action };

      let parsedDetails = details;      select.addEventListener('change', onSelectChange);

      if (typeof details === 'string') {      const cancelBtn = document.getElementById('modalCancel');

        try {      const addBtn = document.getElementById('modalAdd');

          parsedDetails = JSON.parse(details);      cancelBtn.addEventListener('click', onCancel);

        } catch (e) {      addBtn.addEventListener('click', onAdd);

          parsedDetails = details;    }

        }

      }  // --- Wire UI buttons ---

      if (parsedDetails && typeof parsedDetails === 'object' && !Array.isArray(parsedDetails)) {  logSetBtn.addEventListener('click', () => logSet('strength'));

        for (const k of Object.keys(parsedDetails)) {  logRunBtn.addEventListener('click', () => logSet('cardio'));

          if (k === 'action' || k === '_token') continue;  addExerciseBtn.addEventListener('click', () => addExercise());

          payload[k] = parsedDetails[k];

        }  // legacy token/test debug handlers removed from main UI

      } else {    

        payload.details = parsedDetails;    

      }    

      try {    

        if (SHEETS_SECRET_TOKEN) payload._token = SHEETS_SECRET_TOKEN;    

        const localToken = localStorage.getItem(SHEETS_LOCAL_TOKEN_KEY);    

        if (localToken) payload._token = localToken;    

      } catch (e) {}    

      try {    

        const res = await fetch(SHEETS_WEB_APP_URL, {    

          method: 'POST',    

          body: JSON.stringify(payload),  // --- previous token/test handlers (no visible buttons now) ---

        });  // kept in case you want to re-enable them later

        if (!res.ok) {  // setSheetTokenBtn.addEventListener('click', () => { ... })

          const txt = await res.text().catch(() => '<no body>');    

          console.warn('Log failed', res.status, txt);    

          return { ok: false, status: res.status, text: txt };    

        }    

        try {    

          const json = await res.json();    

          return json;    

        } catch (e) {    

          return { ok: true };    

        }    

      } catch (err) {    

        console.warn('Log error', err);    

        return { ok: false, error: String(err) };    

      }    

    }    

    

    // --- Offline queue ---    

    const ACTION_QUEUE_KEY = 'gym-log-queue';    

    const syncStatusEl = document.getElementById('syncStatus');    

    

    function updateSyncStatus() {  // ---

      try {    

        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');    

        const pending = q.length || 0;    

        if (!navigator.onLine) {    

          syncStatusEl.textContent = `‚ö†Ô∏è Offline ‚Äî ${pending} pending`;    

        } else if (pending > 0) {    

          syncStatusEl.textContent = `üîÅ ${pending} pending`;    

        } else {    

          syncStatusEl.textContent = `‚úÖ All synced`;    

        }    

      } catch (e) {    

        syncStatusEl.textContent = navigator.onLine ? '‚úÖ Online' : '‚ö†Ô∏è Offline';    

      }    

    }    

    

    async function enqueueAction(action, details = '') {    

      const fingerprint = JSON.stringify({ action, details });    

      const item = { action, details, ts: new Date().toISOString(), fingerprint };    

      if (navigator.onLine) {    

        try {    

          const res = await logActionToSheet(action, details);    

          if (res && res.ok) {    

            try {    

              const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');    

              const filtered = q.filter((it) => it.fingerprint !== fingerprint);    

              if (filtered.length !== q.length) {    

                localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(filtered));    

              }    

            } catch (e) {}    

            updateSyncStatus();    

            return { ok: true, sent: true, res };    

          }    

        } catch (e) {}    

      }    

      try {    

        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');    

        const exists = q.some((it) => it.fingerprint === fingerprint);    

        if (!exists) {    

          q.push(item);    

        }    

        localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(q));    

        updateSyncStatus();    

        return { ok: false, queued: true };    

      } catch (e) {    

        console.warn('Queue error', e);    

        return { ok: false, error: String(e) };    

      }    

    }    

    

    async function flushQueue() {    

      try {    

        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');    

        if (!q || q.length === 0) return updateSyncStatus();    

        updateSyncStatus();    

        const remaining = [];    

        const sentFingerprints = [];    

        for (const item of q) {    

          try {    

            const res = await logActionToSheet(item.action, item.details);    

            if (res && res.ok) {    

              sentFingerprints.push(item.fingerprint);    

            } else {    

              remaining.push(item);    

            }    

          } catch (e) {    

            remaining.push(item);    

          }    

        }    

        try {    

          let current = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');    

          if (sentFingerprints.length > 0 && Array.isArray(current) && current.length > 0) {    

            current = current.filter((it) => !sentFingerprints.includes(it.fingerprint));    

            const merged = current.concat(remaining.filter(r => !current.some(c => c.fingerprint === r.fingerprint)));    

            localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(merged));    

          } else {    

            localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(remaining));    

          }    

        } catch (e) {    

          localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(remaining));    

        }    

        updateSyncStatus();    

        return { ok: true, remaining: remaining.length };    

      } catch (e) {    

        console.warn('Flush queue error', e);    

        updateSyncStatus();    

        return { ok: false, error: String(e) };    

      }    

    }    

    

    // --- Queue UI ---    

    const queueListEl = document.getElementById('queueList');    

    const retryQueueBtn = document.getElementById('retryQueue');    

    const clearQueueBtn = document.getElementById('clearQueue');    

    const downloadQueueBtn = document.getElementById('downloadQueue');    

    

    function renderQueue() {    

      try {    

        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');    

        if (!queueListEl) return;    

        queueListEl.innerHTML = '';    

        if (!q || q.length === 0) {    

          queueListEl.textContent = 'No pending actions';    

          return;    

        }    

        q.forEach((item) => {    

          const el = document.createElement('div');    

          el.style.cssText = 'display:flex; justify-content:space-between; align-items:center; padding:6px 4px; border-bottom:1px solid rgba(255,255,255,0.03)';    

          const left = document.createElement('div');    

          left.style.flex = '1';    

          left.innerHTML = `<div><strong>${item.action}</strong> <span style="opacity:0.7">${new Date(item.ts).toLocaleString()}</span></div><div style="opacity:0.85;font-size:12px">${String(item.details).slice(0,80)}...</div>`;    

          const right = document.createElement('div');    

          right.style.cssText = 'display:flex; gap:6px';    

          const retryBtn = document.createElement('button');    

          retryBtn.textContent = 'Retry';    

          retryBtn.className = 'secondary';    

          retryBtn.style.fontSize = '12px';    

          retryBtn.style.padding = '6px 10px';

          retryBtn.addEventListener('click', async () => {    clearBtn.addEventListener("click", () => {

            retryBtn.disabled = true;      textarea.value = "";

            try {      localStorage.removeItem(STORAGE_KEY);

              const res = await logActionToSheet(item.action, item.details);      flashStatus("Cleared ‚úîÔ∏è");

              if (res && res.ok) {      try {

                const q2 = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');        enqueueAction('clear', '').catch(() => {});

                const filtered = q2.filter((it) => it.fingerprint !== item.fingerprint);      } catch (e) {}

                localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(filtered));    });

                renderQueue();

                updateSyncStatus();    // --- Service worker registration (helps installability + offline) ---

                flashStatus('Retried ‚úîÔ∏è');    // sw.js must be in the same folder as this index.html

              } else {    if ("serviceWorker" in navigator) {

                flashStatus('Retry failed');      window.addEventListener("load", async () => {

              }        try {

            } catch (e) {          const reg = await navigator.serviceWorker.register("./sw.js");

              flashStatus('Retry failed');          // Optional: you can show this if you want

            }          // console.log("Service worker registered:", reg.scope);

            retryBtn.disabled = false;        } catch (err) {

          });          console.warn("Service worker registration failed:", err);

          const delBtn = document.createElement('button');          flashStatus("SW failed to register (check console) ‚ö†Ô∏è", 2000);

          delBtn.textContent = 'Remove';        }

          delBtn.className = 'secondary';      });

          delBtn.style.fontSize = '12px';    }

          delBtn.style.padding = '6px 10px';

          delBtn.addEventListener('click', () => {    // Tiny debug info to help confirm install / context

            const q2 = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');    const isStandalone =

            const filtered = q2.filter((it) => it.fingerprint !== item.fingerprint);      window.matchMedia("(display-mode: standalone)").matches ||

            localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(filtered));      window.navigator.standalone === true;

            renderQueue();

            updateSyncStatus();    const href = window.location.href;

            flashStatus('Removed');    pwaInfo.innerHTML = isStandalone

          });      ? "‚úÖ Running as an installed app (standalone)."

          right.appendChild(retryBtn);      : `‚ÑπÔ∏è Not installed yet.<br/>

          right.appendChild(delBtn);         In Chrome: menu ‚ãÆ ‚Üí <b>Install app</b> (or <b>Add to Home screen</b>).<br/>

          el.appendChild(left);         If you don‚Äôt see it, confirm these load with 200 OK:<br/>

          el.appendChild(right);         ‚Ä¢ <code>manifest.json</code> ‚Ä¢ <code>sw.js</code> ‚Ä¢ icons.<br/>

          queueListEl.appendChild(el);         <span class="mono">URL:</span> <code>${href}</code>`;

        });  </script>

      } catch (e) {  <!-- Google Identity Services (for Drive backup) -->

        console.warn('Render queue error', e);  <script src="https://accounts.google.com/gsi/client" async defer></script>

      }

    }  <script>

    // --- Backup / Restore helpers ---

    retryQueueBtn.addEventListener('click', async () => {    // STORAGE_KEY and textarea exist in the outer script above

      retryQueueBtn.disabled = true;    const backupBtn = document.getElementById('backupDrive');

      flashStatus('Retrying...', 2000);    const restoreBtn = document.getElementById('restoreDrive');

      await flushQueue();    const exportBtn = document.getElementById('exportBtn');

      renderQueue();    const importBtn = document.getElementById('importBtn');

      retryQueueBtn.disabled = false;    const fileInput = document.getElementById('fileInput');

    });

  // Google Drive OAuth client id placeholder. Replace with your own client ID.

    clearQueueBtn.addEventListener('click', () => {  const GSI_CLIENT_ID = 'YOUR_CLIENT_ID.apps.googleusercontent.com';

      localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify([]));    const GSI_SCOPE = 'https://www.googleapis.com/auth/drive.file'; // creates files visible in Drive

      renderQueue();

      updateSyncStatus();    let gsiTokenClient = null;

      flashStatus('Queue cleared');    let gsiAccessToken = null;

    });

    function initGsiClient() {

    downloadQueueBtn.addEventListener('click', () => {      if (!window.google || !google.accounts || !google.accounts.oauth2) return;

      const q = localStorage.getItem(ACTION_QUEUE_KEY) || '[]';      gsiTokenClient = google.accounts.oauth2.initTokenClient({

      const blob = new Blob([q], { type: 'application/json' });        client_id: GSI_CLIENT_ID,

      const url = URL.createObjectURL(blob);        scope: GSI_SCOPE,

      const a = document.createElement('a');        callback: (tokenResponse) => {

      a.href = url;          if (tokenResponse && tokenResponse.access_token) {

      a.download = `gym-log-queue-${new Date().toISOString()}.json`;            gsiAccessToken = tokenResponse.access_token;

      document.body.appendChild(a);            flashStatus('Google Drive: signed in ‚úîÔ∏è', 2000);

      a.click();          } else {

      a.remove();            flashStatus('Google Drive: sign-in failed', 3000);

      URL.revokeObjectURL(url);          }

      flashStatus('Downloaded');        }

    });      });

    }

    setTimeout(renderQueue, 800);

    // --- Logging to Google Sheets (Apps Script) ---

    window.addEventListener('online', () => {  // Configure these placeholders with your Apps Script web app URL and secret token.

      updateSyncStatus();  const SHEETS_WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbwHk6otl1AmaEIBzZnPvfQX9055EOY2t3AnrqFFNpK93axNDtnF6r5AmkjO6XO505M2ew/exec';

      setTimeout(flushQueue, 800);  // Removed secret from repo. If your Apps Script now accepts anonymous posts,

    });  // leave this empty. To use a secret again, set it locally in your browser

    window.addEventListener('offline', updateSyncStatus);  // (e.g. via localStorage) instead of committing it here.

    window.addEventListener('load', () => {  const SHEETS_SECRET_TOKEN = '';

      setTimeout(() => {  const SHEETS_LOCAL_TOKEN_KEY = 'gym-log-sheet-token';

        updateSyncStatus();

        flushQueue();    async function logActionToSheet(action, details = '') {

      }, 1200);      if (!SHEETS_WEB_APP_URL || SHEETS_WEB_APP_URL.includes('REPLACE_WITH')) return false;

    });      // Build payload carefully: if `details` is a JSON string or an object

  </script>      // that contains fields like `sets` or `rows`, merge those fields into

</body>      // the top-level payload so the Apps Script receives them as top-level keys.

</html>      let payload = { action };

      // attempt to parse details if it's a JSON string
      let parsedDetails = details;
      if (typeof details === 'string') {
        try {
          parsedDetails = JSON.parse(details);
        } catch (e) {
          // leave as string
          parsedDetails = details;
        }
      }
      if (parsedDetails && typeof parsedDetails === 'object' && !Array.isArray(parsedDetails)) {
        // merge keys from parsedDetails into payload (but don't override action or _token)
        for (const k of Object.keys(parsedDetails)) {
          if (k === 'action' || k === '_token') continue;
          payload[k] = parsedDetails[k];
        }
      } else {
        // not an object ‚Äî send as details field
        payload.details = parsedDetails;
      }
      // Include token only when explicitly set in constant or locally in browser storage
      try {
        if (SHEETS_SECRET_TOKEN) payload._token = SHEETS_SECRET_TOKEN;
        const localToken = localStorage.getItem(SHEETS_LOCAL_TOKEN_KEY);
        if (localToken) payload._token = localToken;
      } catch (e) {
        // ignore localStorage errors (e.g., privacy mode)
      }
      try {
        // Send as plain text (no custom Content-Type) to avoid triggering CORS preflight.
        // Apps Script doPost can read the raw body from e.postData.contents and JSON.parse it.
        const res = await fetch(SHEETS_WEB_APP_URL, {
          method: 'POST',
          body: JSON.stringify(payload),
          // don't set headers here to keep request simple (text/plain) and avoid preflight
        });
        if (!res.ok) {
          // non-2xx (may also be blocked by CORS and thrown as an exception)
          const txt = await res.text().catch(() => '<no body>');
          console.warn('Log failed', res.status, txt);
          return { ok: false, status: res.status, text: txt };
        }
        // Some deployments (if CORS is misconfigured) may not allow reading the response; handle safely
        try {
          const json = await res.json();
          return json;
        } catch (e) {
          return { ok: true };
        }
      } catch (err) {
        console.warn('Log error', err);
        return { ok: false, error: String(err) };
      }
    }

    // --- Offline queue & sync helpers ---
    const ACTION_QUEUE_KEY = 'gym-log-queue';
    const syncStatusEl = document.getElementById('syncStatus');

    function updateSyncStatus() {
      try {
        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
        const pending = q.length || 0;
        if (!navigator.onLine) {
          syncStatusEl.textContent = `‚ö†Ô∏è Offline ‚Äî ${pending} pending action(s)`;
        } else if (pending > 0) {
          syncStatusEl.textContent = `üîÅ ${pending} pending action(s) ‚Äî syncing...`;
        } else {
          syncStatusEl.textContent = `‚úÖ Online ‚Äî all synced`;
        }
      } catch (e) {
        syncStatusEl.textContent = navigator.onLine ? '‚úÖ Online' : '‚ö†Ô∏è Offline';
      }
    }

    async function enqueueAction(action, details = '') {
      const fingerprint = JSON.stringify({ action, details });
      const item = { action, details, ts: new Date().toISOString(), fingerprint };
      // Try to send immediately when online
      if (navigator.onLine) {
        try {
          const res = await logActionToSheet(action, details);
          if (res && res.ok) {
            // Remove any previously queued items that match this action/details to avoid duplicates
            try {
              const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
              const filtered = q.filter((it) => it.fingerprint !== fingerprint);
              if (filtered.length !== q.length) {
                localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(filtered));
              }
            } catch (e) {
              // ignore
            }
            updateSyncStatus();
            return { ok: true, sent: true, res };
          }
        } catch (e) {
          // fall through to queueing
        }
      }
      // queue locally
      try {
        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
        // avoid exact-duplicate queue entries (same fingerprint)
        const exists = q.some((it) => it.fingerprint === fingerprint);
        if (!exists) {
          q.push(item);
        }
        localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(q));
        updateSyncStatus();
        return { ok: false, queued: true };
      } catch (e) {
        console.warn('Queue error', e);
        return { ok: false, error: String(e) };
      }
    }

    async function flushQueue() {
      try {
        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
        if (!q || q.length === 0) return updateSyncStatus();
        updateSyncStatus();
        const remaining = [];
        const sentFingerprints = [];
        for (const item of q) {
          try {
            const res = await logActionToSheet(item.action, item.details);
            if (res && res.ok) {
              // mark this fingerprint as successfully sent
              sentFingerprints.push(item.fingerprint);
            } else {
              remaining.push(item);
            }
          } catch (e) {
            remaining.push(item);
          }
        }
        // To avoid races where the stored queue changed while we were sending,
        // read the latest queue and filter out any items we know were sent.
        try {
          let current = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
          if (sentFingerprints.length > 0 && Array.isArray(current) && current.length > 0) {
            current = current.filter((it) => !sentFingerprints.includes(it.fingerprint));
            // merge any items that failed during this run (remaining) ensuring order is preserved
            // but avoid duplicating items already present
            const remainingFingerprints = new Set((remaining || []).map(r => r.fingerprint));
            const merged = current.concat(remaining.filter(r => !current.some(c => c.fingerprint === r.fingerprint)));
            localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(merged));
          } else {
            localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(remaining));
          }
        } catch (e) {
          // fallback to the conservative write
          localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(remaining));
        }
        updateSyncStatus();
        return { ok: true, remaining: remaining.length };
      } catch (e) {
        console.warn('Flush queue error', e);
        updateSyncStatus();
        return { ok: false, error: String(e) };
      }
    }

    // --- Queue viewer & management UI ---
    const queueListEl = document.getElementById('queueList');
    const retryQueueBtn = document.getElementById('retryQueue');
    const clearQueueBtn = document.getElementById('clearQueue');
    const downloadQueueBtn = document.getElementById('downloadQueue');

    function renderQueue() {
      try {
        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
        if (!queueListEl) return;
        queueListEl.innerHTML = '';
        if (!q || q.length === 0) {
          queueListEl.textContent = 'No pending actions';
          return;
        }
        q.forEach((item, idx) => {
          const el = document.createElement('div');
          el.style.display = 'flex';
          el.style.justifyContent = 'space-between';
          el.style.alignItems = 'center';
          el.style.padding = '6px 4px';
          el.style.borderBottom = '1px solid rgba(255,255,255,0.03)';
          const left = document.createElement('div');
          left.style.flex = '1';
          left.innerHTML = `<div><strong>${item.action}</strong> <span style="opacity:0.7">${new Date(item.ts).toLocaleString()}</span></div><div style="opacity:0.85">${String(item.details).slice(0,200)}</div>`;
          const right = document.createElement('div');
          right.style.display = 'flex';
          right.style.gap = '6px';
          const retryBtn = document.createElement('button');
          retryBtn.textContent = 'Retry';
          retryBtn.className = 'secondary';
          retryBtn.addEventListener('click', async () => {
            retryBtn.disabled = true;
            try {
              const res = await logActionToSheet(item.action, item.details);
              if (res && res.ok) {
                // remove any queued items matching this fingerprint (safer than splice-by-index)
                try {
                  const q2 = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
                  const filtered = q2.filter((it) => it.fingerprint !== item.fingerprint);
                  localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(filtered));
                } catch (e) {
                  // ignore
                }
                renderQueue();
                updateSyncStatus();
                flashStatus('Retried and removed ‚úîÔ∏è');
              } else {
                flashStatus('Retry failed (see console)');
                console.warn('Retry response', res);
              }
            } catch (e) {
              console.warn('Retry error', e);
              flashStatus('Retry failed');
            }
            retryBtn.disabled = false;
          });
          const delBtn = document.createElement('button');
          delBtn.textContent = 'Remove';
          delBtn.className = 'secondary';
          delBtn.addEventListener('click', () => {
            try {
              const q2 = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
              const filtered = q2.filter((it) => it.fingerprint !== item.fingerprint);
              localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(filtered));
            } catch (e) {
              // ignore
            }
            renderQueue();
            updateSyncStatus();
            flashStatus('Removed from queue');
          });
          right.appendChild(retryBtn);
          right.appendChild(delBtn);
          el.appendChild(left);
          el.appendChild(right);
          queueListEl.appendChild(el);
        });
      } catch (e) {
        console.warn('Render queue error', e);
      }
    }

    retryQueueBtn.addEventListener('click', async () => {
      retryQueueBtn.disabled = true;
      flashStatus('Retrying queue‚Ä¶', 2000);
      await flushQueue();
      renderQueue();
      retryQueueBtn.disabled = false;
    });

    clearQueueBtn.addEventListener('click', () => {
      localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify([]));
      renderQueue();
      updateSyncStatus();
      flashStatus('Queue cleared');
    });

    downloadQueueBtn.addEventListener('click', () => {
      const q = localStorage.getItem(ACTION_QUEUE_KEY) || '[]';
      const blob = new Blob([q], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `gym-log-queue-${new Date().toISOString()}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      flashStatus('Queue downloaded');
    });

    // render initially
    setTimeout(renderQueue, 800);

    // Attempt to flush when connection returns
    window.addEventListener('online', () => {
      updateSyncStatus();
      setTimeout(flushQueue, 800);
    });
    window.addEventListener('offline', updateSyncStatus);
    // Try flushing shortly after load
    window.addEventListener('load', () => {
      setTimeout(() => {
        updateSyncStatus();
        flushQueue();
      }, 1200);
    });

    window.addEventListener('load', () => {
      // Give the GSI script a moment and init
      setTimeout(initGsiClient, 600);
    });

    function requestDriveToken(interactive = true) {
      if (!gsiTokenClient) return flashStatus('GSI not ready', 2000);
      gsiTokenClient.requestAccessToken({ prompt: interactive ? 'consent' : '' });
    }

    // Upload backup text to Drive (creates a file in user's Drive root)
    async function uploadBackupToDrive(text, filename = `gym-log-backup-${new Date().toISOString()}.txt`) {
      if (!gsiAccessToken) {
        requestDriveToken(true);
        return;
      }

      const metadata = { name: filename };
      const boundary = '-------314159265358979323846';
      const delimiter = `\r\n--${boundary}\r\n`;
      const closeDelimiter = `\r\n--${boundary}--`;

      const multipartRequestBody =
        delimiter +
        'Content-Type: application/json; charset=UTF-8\r\n\r\n' +
        JSON.stringify(metadata) +
        '\r\n' +
        delimiter +
        'Content-Type: text/plain\r\n\r\n' +
        text +
        closeDelimiter;

      const res = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name', {
        method: 'POST',
        headers: {
          Authorization: 'Bearer ' + gsiAccessToken,
          'Content-Type': `multipart/related; boundary=${boundary}`
        },
        body: multipartRequestBody
      });

      if (!res.ok) {
        const txt = await res.text();
        console.error('Drive upload failed', res.status, txt);
        flashStatus('Drive upload failed', 3000);
        return null;
      }

      const payload = await res.json();
      flashStatus('Backup uploaded to Drive ‚úîÔ∏è', 2500);
      try {
        enqueueAction('backup_drive_done', JSON.stringify(payload)).catch(() => {});
      } catch (e) {}
      return payload;
    }

    // List files created by this app (search by name prefix)
    async function listBackups() {
      if (!gsiAccessToken) {
        requestDriveToken(true);
        return [];
      }
      const q = `name contains 'gym-log-backup'`;
      const url = `https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(q)}&fields=files(id,name,modifiedTime)`;
      const res = await fetch(url, { headers: { Authorization: 'Bearer ' + gsiAccessToken } });
      if (!res.ok) return [];
      const data = await res.json();
      return data.files || [];
    }

    async function downloadBackup(fileId) {
      if (!gsiAccessToken) {
        requestDriveToken(true);
        return null;
      }
      const url = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`;
      const res = await fetch(url, { headers: { Authorization: 'Bearer ' + gsiAccessToken } });
      if (!res.ok) {
        flashStatus('Download failed', 3000);
        return null;
      }
      return await res.text();
    }

    // --- Export / Import (local) ---
    function exportToFile(text, filename = 'gym-log-export.txt') {
      const blob = new Blob([text], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      flashStatus('Exported .txt ‚úîÔ∏è', 1800);
      try {
        enqueueAction('export', JSON.stringify({ filename })).catch(() => {});
      } catch (e) {}
    }

    fileInput.addEventListener('change', async (ev) => {
      const f = ev.target.files && ev.target.files[0];
      if (!f) return;
      const txt = await f.text();
      textarea.value = txt;
      localStorage.setItem(STORAGE_KEY, txt);
      flashStatus('Imported .txt ‚úîÔ∏è', 1800);
      try {
        enqueueAction('import', JSON.stringify({ name: f.name, size: f.size })).catch(() => {});
      } catch (e) {}
      fileInput.value = '';
    });

    // --- button bindings ---
    exportBtn.addEventListener('click', () => exportToFile(textarea.value));

    importBtn.addEventListener('click', () => fileInput.click());

    backupBtn.addEventListener('click', async () => {
      // If client id not replaced, notify user
      if (GSI_CLIENT_ID.includes('YOUR_CLIENT_ID')) {
        flashStatus('Please set your Google Client ID in the code to use Drive backup.', 4000);
        return;
      }
      // Ensure token client is initialized
      if (!gsiTokenClient) initGsiClient();
      if (!gsiAccessToken) {
        requestDriveToken(true);
        // Wait a short while for interactive consent to complete before attempting upload
        setTimeout(() => uploadBackupToDrive(textarea.value), 1200);
        return;
      }
      await uploadBackupToDrive(textarea.value);
    });

    restoreBtn.addEventListener('click', async () => {
      if (GSI_CLIENT_ID.includes('YOUR_CLIENT_ID')) {
        flashStatus('Please set your Google Client ID in the code to use Drive restore.', 4000);
        return;
      }
      if (!gsiTokenClient) initGsiClient();
      if (!gsiAccessToken) {
        requestDriveToken(true);
        setTimeout(async () => {
          const files = await listBackups();
          if (!files || files.length === 0) return flashStatus('No backups found', 2000);
          // pick the most recent by modifiedTime
          files.sort((a,b) => new Date(b.modifiedTime) - new Date(a.modifiedTime));
          const content = await downloadBackup(files[0].id);
          if (content != null) {
            textarea.value = content;
            localStorage.setItem(STORAGE_KEY, content);
            flashStatus('Restored from Drive ‚úîÔ∏è', 2000);
            try {
              enqueueAction('restore_drive', JSON.stringify({ id: files[0].id, name: files[0].name })).catch(() => {});
            } catch (e) {}
          }
        }, 1200);
        return;
      }

      const files = await listBackups();
      if (!files || files.length === 0) return flashStatus('No backups found', 2000);
      files.sort((a,b) => new Date(b.modifiedTime) - new Date(a.modifiedTime));
      const content = await downloadBackup(files[0].id);
      if (content != null) {
        textarea.value = content;
        localStorage.setItem(STORAGE_KEY, content);
        flashStatus('Restored from Drive ‚úîÔ∏è', 2000);
        try {
          enqueueAction('restore_drive', JSON.stringify({ id: files[0].id, name: files[0].name })).catch(() => {});
        } catch (e) {}
      }
    });
  </script>
</body>
</html>
