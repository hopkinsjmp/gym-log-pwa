<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Gym Log</title>

  <!-- PWA basics -->
  <meta name="theme-color" content="#111827" />
  <link rel="manifest" href="./manifest.json" />

  <!-- Nice-to-haves (Android/Chrome + iOS-ish) -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="GymLog" />

  <!-- Optional: you can add an iOS icon later if you want -->
  <!-- <link rel="apple-touch-icon" href="./icon-192.png" /> -->

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 16px;
      background: #111827;
      color: #f9fafb;
    }

    h1 {
      margin: 0 0 12px;
      font-size: 1.4rem;
    }

    .hint {
      margin: 0 0 12px;
      opacity: 0.75;
      font-size: 0.95rem;
      line-height: 1.3;
    }

    textarea {
      width: 100%;
      min-height: 240px;
      padding: 12px;
      font-size: 16px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: #f9fafb;
      outline: none;
      resize: vertical;
      box-sizing: border-box;
    }

    textarea:focus {
      border-color: rgba(124, 58, 237, 0.7);
      box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.25);
    }

    .row {
      display: flex;
      gap: 10px;
      margin-top: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    button {
      padding: 12px 16px;
      font-size: 16px;
      border-radius: 10px;
      border: none;
      background: #7c3aed;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }

    button.secondary {
      background: rgba(255,255,255,0.12);
      color: #f9fafb;
    }

    .status {
      font-size: 0.95rem;
      opacity: 0.85;
      min-height: 1.2em;
    }

    .tiny {
      font-size: 0.85rem;
      opacity: 0.75;
      margin-top: 10px;
      line-height: 1.35;
    }

    code {
      background: rgba(255,255,255,0.08);
      padding: 2px 6px;
      border-radius: 6px;
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* iOS-style picker wheel */
    .picker-container {
      display: flex;
      gap: 0;
      margin: 0;
      align-items: stretch;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.06);
      position: relative;
      height: 120px;
    }

    .picker-container::before,
    .picker-container::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      height: 40px;
      pointer-events: none;
      z-index: 2;
    }

    .picker-container::before {
      top: 0;
      background: linear-gradient(to bottom, rgba(11,18,32,1) 0%, rgba(11,18,32,0.85) 60%, transparent 100%);
      border-radius: 8px 8px 0 0;
    }

    .picker-container::after {
      bottom: 0;
      background: linear-gradient(to top, rgba(11,18,32,1) 0%, rgba(11,18,32,0.85) 60%, transparent 100%);
      border-radius: 0 0 8px 8px;
    }

    .picker-selection {
      position: absolute;
      left: 0;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      height: 32px;
      border-top: 0.5px solid rgba(255,255,255,0.2);
      border-bottom: 0.5px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.02);
      pointer-events: none;
      z-index: 1;
    }

    .picker-wheel {
      position: relative;
      flex: 1;
      overflow: hidden;
    }

    .picker-scroll {
      position: relative;
      padding: 44px 0;
      transition: transform 0.15s ease-out;
    }

    .picker-item {
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: 400;
      cursor: pointer;
      user-select: none;
      opacity: 0.3;
      transition: opacity 0.15s, font-size 0.15s;
    }

    .picker-item.selected {
      opacity: 1;
      font-size: 20px;
      font-weight: 500;
    }

    .picker-label {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      opacity: 0.6;
      pointer-events: none;
      z-index: 3;
      font-weight: 400;
    }

    .set-row {
      margin-bottom: 10px;
      position: relative;
    }

    .set-row .set-number {
      font-size: 13px;
      font-weight: 600;
      opacity: 0.7;
      margin-bottom: 4px;
    }

    .remove-set-btn {
      position: absolute;
      top: 0;
      right: 0;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #ef4444;
      color: white;
      border: none;
      font-size: 16px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .remove-set-btn:hover {
      background: #dc2626;
    }

    .add-set-btn {
      width: 100%;
      padding: 10px;
      margin-top: 4px;
      background: rgba(124, 58, 237, 0.15);
      border: 1px dashed rgba(124, 58, 237, 0.4);
      border-radius: 8px;
      color: #a78bfa;
      font-size: 24px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .add-set-btn:hover {
      background: rgba(124, 58, 237, 0.25);
      border-color: rgba(124, 58, 237, 0.6);
    }
  </style>
</head>

<body>
  <h1>üèãÔ∏è Gym Log</h1>
  <p class="hint">Quick logging for strength training and cardio. All workouts sync to Google Sheets.</p>

  <div class="row">
    <button id="logSet" type="button">Log Set</button>
    <button id="logRun" type="button">Log Run</button>
    <button id="addExercise" class="secondary" type="button">Add Exercise</button>
  </div>

  <div class="status" id="status" style="margin-top:8px;"></div>
  <div class="status" id="syncStatus" style="margin-top:6px; font-size:0.9rem; opacity:0.9"></div>

  <!-- Pending actions queue panel -->
  <div id="queuePanel" style="margin-top:16px; padding:10px; border-radius:8px; background:rgba(255,255,255,0.02);">
    <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
      <div style="font-weight:700">Pending sync</div>
      <div style="display:flex; gap:8px;">
        <button id="retryQueue" class="secondary" type="button">Retry all</button>
        <button id="downloadQueue" class="secondary" type="button">Download</button>
        <button id="clearQueue" class="secondary" type="button">Clear</button>
      </div>
    </div>
    <div id="queueList" style="margin-top:8px; max-height:180px; overflow:auto; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; font-size:13px;"></div>
  </div>

  <div class="tiny" id="pwaInfo"></div>

  <!-- Add-Set modal -->
  <div id="addSetModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); align-items:center; justify-content:center; z-index:9999; overflow-y:auto; padding:20px 0;">
    <div style="background:#0b1220; padding:16px; border-radius:12px; width:92%; max-width:420px; box-shadow:0 10px 30px rgba(0,0,0,0.6); color:#f9fafb; margin:auto;">
      <h3 style="margin:0 0 8px; font-size:1.1rem;">Add Set(s)</h3>
      <div style="display:flex; gap:8px; flex-direction:column;">
        <label class="mono" style="font-size:0.9rem; opacity:0.9">Exercise</label>
        <select id="modalExerciseSelect" style="padding:8px; border-radius:8px; background:rgba(255,255,255,0.04); color:#f9fafb; border:1px solid rgba(255,255,255,0.06)">
          <option value="__new__">-- New exercise --</option>
        </select>
        <input id="modalExerciseNew" placeholder="If new: name" style="padding:8px; border-radius:8px; background:rgba(255,255,255,0.03); color:#f9fafb; border:1px solid rgba(255,255,255,0.06); display:none;" />

        <!-- Individual sets container -->
        <div id="setsContainer" style="max-height:500px; overflow-y:auto; margin-top:12px;">
          <!-- Sets will be dynamically added here -->
        </div>

        <!-- Cardio fields (hidden for strength mode) -->
        <div id="modalCardioFields" style="display:none;">
          <div style="display:flex; gap:8px;">
            <div style="flex:1">
              <label class="mono" style="font-size:0.9rem; opacity:0.9">Duration (s)</label>
              <input id="modalDuration" type="number" min="0" placeholder="seconds" style="width:100%; padding:8px; border-radius:8px; background:rgba(255,255,255,0.03); color:#f9fafb; border:1px solid rgba(255,255,255,0.06);" />
            </div>
            <div style="width:120px">
              <label class="mono" style="font-size:0.9rem; opacity:0.9">Distance (km)</label>
              <input id="modalDistance" type="number" step="0.01" placeholder="km" style="width:100%; padding:8px; border-radius:8px;" />
            </div>
          </div>
        </div>

        <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:8px;">
          <button id="modalCancel" class="secondary" type="button">Cancel</button>
          <button id="modalAdd" type="button">Add</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const statusEl = document.getElementById("status");
    const pwaInfo = document.getElementById("pwaInfo");
    const logSetBtn = document.getElementById('logSet');
    const logRunBtn = document.getElementById('logRun');
    const addExerciseBtn = document.getElementById('addExercise');

    function flashStatus(msg, ms = 1500) {
      statusEl.textContent = msg;
      window.clearTimeout(flashStatus._t);
      flashStatus._t = window.setTimeout(() => (statusEl.textContent = ""), ms);
    }

  // --- Structured data helpers (exercises + sets store) ---
    const EXERCISES_KEY = 'gym-exercises';
    const SETS_KEY = 'gym-sets';

    // Exercises are a global list saved to localStorage so they persist across sessions/devices (and can be synced to the Sheet).
    function loadExercises() {
      try {
        return JSON.parse(localStorage.getItem(EXERCISES_KEY) || '[]');
      } catch (e) {
        return [];
      }
    }

    function saveExercises(arr) {
      localStorage.setItem(EXERCISES_KEY, JSON.stringify(arr || []));
      updateExerciseSelect();
    }

    function loadSets() {
      try {
        return JSON.parse(localStorage.getItem(SETS_KEY) || '[]');
      } catch (e) {
        return [];
      }
    }

    function saveSets(arr) {
      localStorage.setItem(SETS_KEY, JSON.stringify(arr || []));
    }

    function updateExerciseSelect() {
      const select = document.getElementById('modalExerciseSelect');
      const exercises = loadExercises();
      // keep the default new option
      const current = select && select.value;
      if (!select) return;
      select.innerHTML = '<option value="__new__">-- New exercise --</option>';
      for (const ex of exercises) {
        const opt = document.createElement('option');
        opt.value = String(ex.id);
        opt.textContent = ex.name;
        select.appendChild(opt);
      }
      // try to reselect previous value
      if (current) select.value = current;
    }

    function loadStructuredData() {
      // Keep backward compatibility: if STORAGE_KEY contains a sessions-based v2 payload,
      // we won't delete it ‚Äî but the app now prefers the global exercises + sets stores.
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      try {
        return JSON.parse(raw);
      } catch (e) {
        return null;
      }
    }

    function saveStructuredData(obj) {
      // Deprecated for new flow ‚Äî keep for compatibility
      localStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
      flashStatus('Saved ‚úîÔ∏è');
    }

    function getCurrentSession(data) {
      // Sessions are optional in the new model. Return null unless the old schema is present.
      const d = data || loadStructuredData();
      if (!d || !d.sessions || d.sessions.length === 0) return null;
      return d.sessions[d.sessions.length - 1];
    }

    // generate a compact client-side id for sets/exercises to help server-side dedupe and lookup
    function generateId() {
      return Date.now().toString(36) + '-' + Math.random().toString(36).slice(2, 9);
    }

    async function newSession() {
      // Sessions are optional; keep behavior for backward compatibility
      const d = loadStructuredData() || { version: 2, sessions: [] };
      const session = { id: Date.now(), date: new Date().toISOString(), notes: '', exercises: [] };
      d.sessions.push(session);
      saveStructuredData(d);
      flashStatus('New session created');
      try { await enqueueAction('new_session', JSON.stringify({ id: session.id, date: session.date })); } catch (e) {}
    }

    async function addExercise() {
      // Add exercise to global exercises list so it's available across sessions/devices
      const name = prompt('Exercise name (e.g. Bench Press)');
      if (!name) return flashStatus('Cancelled', 1200);
      const exercises = loadExercises();
      const ex = { id: Date.now(), name: name.trim(), notes: '' };
      exercises.push(ex);
      saveExercises(exercises);
      flashStatus('Exercise added');
      try { await enqueueAction('upsert_exercise', JSON.stringify(ex)); } catch (e) {}
    }

    async function addSet(mode = 'strength') {
      // Open modal UI for adding sets with iOS-style pickers

      const select = document.getElementById('modalExerciseSelect');
      const newInput = document.getElementById('modalExerciseNew');
      const setsContainer = document.getElementById('setsContainer');
      const cardioFields = document.getElementById('modalCardioFields');
      const durationInput = document.getElementById('modalDuration');
      const distanceInput = document.getElementById('modalDistance');
      const modal = document.getElementById('addSetModal');

      let numberOfSets = 3;
      const setData = []; // Will store {weight: number, reps: number} for each set
      const weightUnit = 'kg'; // Always use kg

      // Create iOS-style picker wheel
      function createPicker(min, max, defaultValue) {
        const wheel = document.createElement('div');
        wheel.className = 'picker-wheel';

        const scroll = document.createElement('div');
        scroll.className = 'picker-scroll';
        
        const items = [];
        for (let i = min; i <= max; i++) {
          const item = document.createElement('div');
          item.className = 'picker-item';
          item.textContent = i;
          item.dataset.value = i;
          scroll.appendChild(item);
          items.push(item);
        }
        
        wheel.appendChild(scroll);

        let currentValue = defaultValue;
        let selectedIndex = items.findIndex(item => Number(item.dataset.value) === defaultValue);
        if (selectedIndex === -1) selectedIndex = 0;
        
        function updatePosition() {
          const offset = selectedIndex * -32;
          scroll.style.transform = `translateY(${offset}px)`;
          items.forEach((item, idx) => {
            item.classList.toggle('selected', idx === selectedIndex);
          });
        }
        
        updatePosition();

        let touchStartY = 0;
        let scrollStartY = 0;
        let isDragging = false;

        function onStart(y) {
          isDragging = true;
          touchStartY = y;
          scrollStartY = selectedIndex * 32;
          scroll.style.transition = 'none';
        }

        function onMove(y) {
          if (!isDragging) return;
          const deltaY = touchStartY - y;
          const newScrollY = scrollStartY + deltaY;
          const newIndex = Math.round(newScrollY / 32);
          const clampedIndex = Math.max(0, Math.min(items.length - 1, newIndex));
          selectedIndex = clampedIndex;
          scroll.style.transform = `translateY(${-clampedIndex * 32}px)`;
          items.forEach((item, idx) => {
            item.classList.toggle('selected', idx === clampedIndex);
          });
        }

        function onEnd() {
          if (!isDragging) return;
          isDragging = false;
          scroll.style.transition = 'transform 0.15s ease-out';
          updatePosition();
          currentValue = Number(items[selectedIndex].dataset.value);
        }

        wheel.addEventListener('mousedown', (e) => {
          e.preventDefault();
          onStart(e.clientY);
        });
        
        wheel.addEventListener('mousemove', (e) => {
          e.preventDefault();
          onMove(e.clientY);
        });
        
        wheel.addEventListener('mouseup', () => onEnd());
        wheel.addEventListener('mouseleave', () => onEnd());

        wheel.addEventListener('touchstart', (e) => {
          onStart(e.touches[0].clientY);
        });
        
        wheel.addEventListener('touchmove', (e) => {
          e.preventDefault();
          onMove(e.touches[0].clientY);
        });
        
        wheel.addEventListener('touchend', () => onEnd());

        return {
          element: wheel,
          getValue: () => currentValue
        };
      }

      // Render individual sets with dual pickers (weight + reps)
      function renderSets() {
        setsContainer.innerHTML = '';
        setData.length = numberOfSets;
        
        for (let i = 0; i < numberOfSets; i++) {
          if (!setData[i]) setData[i] = { weight: 20, reps: 8 };
          
          const setRow = document.createElement('div');
          setRow.className = 'set-row';
          
          const setNumber = document.createElement('div');
          setNumber.className = 'set-number';
          setNumber.textContent = `Set ${i + 1}`;
          setRow.appendChild(setNumber);
          
          // Remove button (only show if more than 1 set)
          if (numberOfSets > 1) {
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-set-btn';
            removeBtn.textContent = '‚àí';
            removeBtn.onclick = (e) => {
              e.preventDefault();
              removeSet(i);
            };
            setRow.appendChild(removeBtn);
          }
          
          const pickerContainer = document.createElement('div');
          pickerContainer.className = 'picker-container';
          
          // Selection bar (shared between both pickers)
          const selection = document.createElement('div');
          selection.className = 'picker-selection';
          pickerContainer.appendChild(selection);
          
          // Weight picker
          const weightPicker = createPicker(0, 200, setData[i].weight);
          const weightLabel = document.createElement('div');
          weightLabel.className = 'picker-label';
          weightLabel.textContent = weightUnit;
          weightPicker.element.appendChild(weightLabel);
          pickerContainer.appendChild(weightPicker.element);
          
          // Reps picker
          const repsPicker = createPicker(0, 50, setData[i].reps);
          const repsLabel = document.createElement('div');
          repsLabel.className = 'picker-label';
          repsLabel.textContent = 'reps';
          repsPicker.element.appendChild(repsLabel);
          pickerContainer.appendChild(repsPicker.element);
          
          setRow.appendChild(pickerContainer);
          setsContainer.appendChild(setRow);
          
          // Store references to pickers
          setData[i].getWeightPicker = () => weightPicker;
          setData[i].getRepsPicker = () => repsPicker;
        }
        
        // Add "+" button at the bottom
        if (numberOfSets < 10) {
          const addBtn = document.createElement('button');
          addBtn.className = 'add-set-btn';
          addBtn.textContent = '+';
          addBtn.onclick = (e) => {
            e.preventDefault();
            addSetRow();
          };
          setsContainer.appendChild(addBtn);
        }
      }
      
      function removeSet(index) {
        if (numberOfSets <= 1) return;
        setData.splice(index, 1);
        numberOfSets--;
        renderSets();
      }
      
      function addSetRow() {
        if (numberOfSets >= 10) return;
        numberOfSets++;
        renderSets();
      }

      // populate exercise list from global exercises store
      updateExerciseSelect();
      const exercises = loadExercises();
      if (exercises && exercises.length) {
        select.value = String(exercises[exercises.length - 1].id);
        newInput.style.display = 'none';
      } else {
        select.value = '__new__';
        newInput.style.display = '';
      }

      // preset values
      durationInput.value = '';
      distanceInput.value = '';

      // show modal
      const header = modal.querySelector('h3');
      header.textContent = mode === 'cardio' ? 'Log Run' : 'Log Set(s)';
      modal.style.display = 'flex';
      
      // adjust fields based on mode
      if (mode === 'cardio') {
        setsContainer.style.display = 'none';
        cardioFields.style.display = '';
        numberOfSets = 1;
      } else {
        setsContainer.style.display = '';
        cardioFields.style.display = 'none';
        renderSets();
      }

      // handlers
      function onSelectChange() {
        if (select.value === '__new__') newInput.style.display = '';
        else newInput.style.display = 'none';
      }

      function closeModal() {
        modal.style.display = 'none';
        select.removeEventListener('change', onSelectChange);
        cancelBtn.removeEventListener('click', onCancel);
        addBtn.removeEventListener('click', onAdd);
      }

      function onCancel() {
        closeModal();
        flashStatus('Cancelled', 900);
      }

      async function onAdd() {
        const durationVal = durationInput.value === '' ? null : Number(durationInput.value);
        const distanceVal = distanceInput.value === '' ? null : Number(distanceInput.value);
        const weightUnit = unitSelect.value;
        
        let exObj = null;
        if (select.value === '__new__') {
          const name = newInput.value && newInput.value.trim();
          if (!name) return flashStatus('Enter exercise name', 1500);
          exObj = { id: Date.now(), name: name, notes: '' };
          const exercises = loadExercises();
          exercises.push(exObj);
          saveExercises(exercises);
        } else {
          const exercises = loadExercises();
          exObj = exercises.find(e => String(e.id) === String(select.value));
          if (!exObj) {
            flashStatus('Exercise not found', 1500);
            return;
          }
        }

        // Add sets with individual weight and rep values
        const sets = loadSets();
        const createdSets = [];
        
        for (let i = 0; i < numberOfSets; i++) {
          const ts = new Date(Date.now() + i * 1000).toISOString();
          const sid = generateId();
          let setObj;
          
          if (mode === 'cardio') {
            setObj = { id: sid, exerciseId: exObj.id, ts, duration_s: durationVal, distance_km: distanceVal };
          } else {
            const weightVal = setData[i].getWeightPicker().getValue();
            const repsVal = setData[i].getRepsPicker().getValue();
            const weightStr = weightVal > 0 ? `${weightVal}${weightUnit}` : '';
            setObj = { id: sid, exerciseId: exObj.id, ts, reps: repsVal, weight: weightStr };
          }
          
          sets.push(setObj);
          createdSets.push(setObj);
        }
        
        saveSets(sets);
        closeModal();
        flashStatus(`${numberOfSets} set(s) added to ${exObj.name}`);
        
        try {
          await enqueueAction('log_set', JSON.stringify({ exerciseId: exObj.id, exercise: exObj.name, sets: createdSets, type: mode }));
        } catch (e) {}
      }

      select.addEventListener('change', onSelectChange);
      
      const cancelBtn = document.getElementById('modalCancel');
      const addBtn = document.getElementById('modalAdd');
      cancelBtn.addEventListener('click', onCancel);
      addBtn.addEventListener('click', onAdd);
    }

    async function exportRowsToSheet() {
      // Flatten global sets list into rows for the Sheet. Each set is one row.
      const sets = loadSets();
      const exercises = loadExercises().reduce((m, e) => { m[e.id] = e; return m; }, {});
      const rows = [];
      for (let i = 0; i < sets.length; i++) {
        const set = sets[i];
        const ex = exercises[set.exerciseId] || { name: '' };
        rows.push({
          exerciseId: set.exerciseId,
          exercise: ex.name,
          setId: set.id,
          setIndex: null,
          setTs: set.ts,
          reps: set.reps,
          weight: set.weight,
          notes: set.notes || ''
        });
      }
      if (rows.length === 0) return flashStatus('No structured rows to export', 2000);
      flashStatus('Exporting rows‚Ä¶', 5000);
      try {
        const res = await enqueueAction('export_rows', JSON.stringify({ rows }));
        if (res && res.ok) {
          flashStatus('Exported rows to Sheet ‚úîÔ∏è', 2500);
        } else if (res && res.queued) {
          flashStatus('Export queued for sync ‚úîÔ∏è', 2500);
        } else {
          console.warn('Export rows response', res);
          flashStatus('Export failed (see console)', 4000);
        }
      } catch (e) {
        console.warn(e);
        flashStatus('Export failed', 3000);
      }
    }

  // --- small UI bindings for main actions ---
  // Wire the three primary buttons: Log Set, Log Run, Add Exercise
  logSetBtn.addEventListener('click', () => addSet('strength'));
  logRunBtn.addEventListener('click', () => addSet('cardio'));
  addExerciseBtn.addEventListener('click', () => addExercise());

  // legacy token/test debug handlers removed from main UI
    
    
    
    
    
    
    
    
    
    
    
  // --- previous token/test handlers (no visible buttons now) ---
  // kept in case you want to re-enable them later
  // setSheetTokenBtn.addEventListener('click', () => { ... })
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  // ---
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    clearBtn.addEventListener("click", () => {
      textarea.value = "";
      localStorage.removeItem(STORAGE_KEY);
      flashStatus("Cleared ‚úîÔ∏è");
      try {
        enqueueAction('clear', '').catch(() => {});
      } catch (e) {}
    });

    // --- Service worker registration (helps installability + offline) ---
    // sw.js must be in the same folder as this index.html
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", async () => {
        try {
          const reg = await navigator.serviceWorker.register("./sw.js");
          // Optional: you can show this if you want
          // console.log("Service worker registered:", reg.scope);
        } catch (err) {
          console.warn("Service worker registration failed:", err);
          flashStatus("SW failed to register (check console) ‚ö†Ô∏è", 2000);
        }
      });
    }

    // Tiny debug info to help confirm install / context
    const isStandalone =
      window.matchMedia("(display-mode: standalone)").matches ||
      window.navigator.standalone === true;

    const href = window.location.href;
    pwaInfo.innerHTML = isStandalone
      ? "‚úÖ Running as an installed app (standalone)."
      : `‚ÑπÔ∏è Not installed yet.<br/>
         In Chrome: menu ‚ãÆ ‚Üí <b>Install app</b> (or <b>Add to Home screen</b>).<br/>
         If you don't see it, confirm these load with 200 OK:<br/>
         ‚Ä¢ <code>manifest.json</code> ‚Ä¢ <code>sw.js</code> ‚Ä¢ icons.<br/>
         <span class="mono">URL:</span> <code>${href}</code>`;
  </script>

  <script>
    // --- Logging to Google Sheets (Apps Script) ---
  // Configure these placeholders with your Apps Script web app URL and secret token.
  const SHEETS_WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbwHk6otl1AmaEIBzZnPvfQX9055EOY2t3AnrqFFNpK93axNDtnF6r5AmkjO6XO505M2ew/exec';
  // Removed secret from repo. If your Apps Script now accepts anonymous posts,
  // leave this empty. To use a secret again, set it locally in your browser
  // (e.g. via localStorage) instead of committing it here.
  const SHEETS_SECRET_TOKEN = '';
  const SHEETS_LOCAL_TOKEN_KEY = 'gym-log-sheet-token';

    async function logActionToSheet(action, details = '') {
      if (!SHEETS_WEB_APP_URL || SHEETS_WEB_APP_URL.includes('REPLACE_WITH')) return false;
      // Build payload carefully: if `details` is a JSON string or an object
      // that contains fields like `sets` or `rows`, merge those fields into
      // the top-level payload so the Apps Script receives them as top-level keys.
      let payload = { action };
      // attempt to parse details if it's a JSON string
      let parsedDetails = details;
      if (typeof details === 'string') {
        try {
          parsedDetails = JSON.parse(details);
        } catch (e) {
          // leave as string
          parsedDetails = details;
        }
      }
      if (parsedDetails && typeof parsedDetails === 'object' && !Array.isArray(parsedDetails)) {
        // merge keys from parsedDetails into payload (but don't override action or _token)
        for (const k of Object.keys(parsedDetails)) {
          if (k === 'action' || k === '_token') continue;
          payload[k] = parsedDetails[k];
        }
      } else {
        // not an object ‚Äî send as details field
        payload.details = parsedDetails;
      }
      // Include token only when explicitly set in constant or locally in browser storage
      try {
        if (SHEETS_SECRET_TOKEN) payload._token = SHEETS_SECRET_TOKEN;
        const localToken = localStorage.getItem(SHEETS_LOCAL_TOKEN_KEY);
        if (localToken) payload._token = localToken;
      } catch (e) {
        // ignore localStorage errors (e.g., privacy mode)
      }
      try {
        // Send as plain text (no custom Content-Type) to avoid triggering CORS preflight.
        // Apps Script doPost can read the raw body from e.postData.contents and JSON.parse it.
        const res = await fetch(SHEETS_WEB_APP_URL, {
          method: 'POST',
          body: JSON.stringify(payload),
          // don't set headers here to keep request simple (text/plain) and avoid preflight
        });
        if (!res.ok) {
          // non-2xx (may also be blocked by CORS and thrown as an exception)
          const txt = await res.text().catch(() => '<no body>');
          console.warn('Log failed', res.status, txt);
          return { ok: false, status: res.status, text: txt };
        }
        // Some deployments (if CORS is misconfigured) may not allow reading the response; handle safely
        try {
          const json = await res.json();
          return json;
        } catch (e) {
          return { ok: true };
        }
      } catch (err) {
        console.warn('Log error', err);
        return { ok: false, error: String(err) };
      }
    }

    // --- Offline queue & sync helpers ---
    const ACTION_QUEUE_KEY = 'gym-log-queue';
    // Persisted list of set IDs we've confirmed were written to the Sheet. This
    // helps avoid re-sending the same set on reloads or across retries.
    const LOGGED_SET_IDS_KEY = 'gym-logged-ids';
    const syncStatusEl = document.getElementById('syncStatus');

    function loadLoggedSetIds() {
      try {
        return JSON.parse(localStorage.getItem(LOGGED_SET_IDS_KEY) || '[]');
      } catch (e) {
        return [];
      }
    }

    function saveLoggedSetIds(arr) {
      try {
        localStorage.setItem(LOGGED_SET_IDS_KEY, JSON.stringify(Array.from(new Set(arr || []))));
      } catch (e) {}
    }

    function addLoggedSetIds(ids) {
      if (!Array.isArray(ids) || ids.length === 0) return;
      const current = loadLoggedSetIds();
      const merged = Array.from(new Set(current.concat(ids)));
      saveLoggedSetIds(merged);
    }

    function updateSyncStatus() {
      try {
        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
        const pending = q.length || 0;
        if (!navigator.onLine) {
          syncStatusEl.textContent = `‚ö†Ô∏è Offline ‚Äî ${pending} pending action(s)`;
        } else if (pending > 0) {
          syncStatusEl.textContent = `üîÅ ${pending} pending action(s) ‚Äî syncing...`;
        } else {
          syncStatusEl.textContent = `‚úÖ Online ‚Äî all synced`;
        }
      } catch (e) {
        syncStatusEl.textContent = navigator.onLine ? '‚úÖ Online' : '‚ö†Ô∏è Offline';
      }
    }

    async function enqueueAction(action, details = '') {
      const fingerprint = JSON.stringify({ action, details });
      const item = { action, details, ts: new Date().toISOString(), fingerprint };
      // Try to send immediately when online
      if (navigator.onLine) {
        try {
          const res = await logActionToSheet(action, details);
          if (res && res.ok) {
            // Remove any previously queued items that match this action/details to avoid duplicates
            try {
              const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
              const filtered = q.filter((it) => it.fingerprint !== fingerprint);
              if (filtered.length !== q.length) {
                localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(filtered));
              }
            } catch (e) {
              // ignore
            }
            // If this was a log_set action, record the set ids that the server
            // accepted so we don't re-send them after a reload.
            try {
              if (action === 'log_set') {
                let parsed = details;
                if (typeof details === 'string') {
                  try { parsed = JSON.parse(details); } catch (e) { parsed = null; }
                }
                if (parsed && Array.isArray(parsed.sets)) {
                  const ids = parsed.sets.map(s => s && s.id).filter(Boolean);
                  if (ids.length) addLoggedSetIds(ids);
                }
              }
            } catch (e) {
              // ignore
            }
            updateSyncStatus();
            return { ok: true, sent: true, res };
          }
        } catch (e) {
          // fall through to queueing
        }
      }
      // queue locally
      try {
        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
        // avoid exact-duplicate queue entries (same fingerprint)
        const exists = q.some((it) => it.fingerprint === fingerprint);
        if (!exists) {
          // If this is a log_set, avoid queueing it if all set ids are already recorded
          let shouldQueue = true;
          if (action === 'log_set') {
            let parsed = details;
            if (typeof details === 'string') {
              try { parsed = JSON.parse(details); } catch (e) { parsed = null; }
            }
            if (parsed && Array.isArray(parsed.sets)) {
              const logged = new Set(loadLoggedSetIds());
              const allLogged = parsed.sets.every(s => s && s.id && logged.has(s.id));
              if (allLogged) shouldQueue = false;
            }
          }
          if (shouldQueue) q.push(item);
        }
        localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(q));
        updateSyncStatus();
        return { ok: false, queued: true };
      } catch (e) {
        console.warn('Queue error', e);
        return { ok: false, error: String(e) };
      }
    }

    async function flushQueue() {
      try {
        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
        if (!q || q.length === 0) return updateSyncStatus();
        updateSyncStatus();
        const remaining = [];
        const sentFingerprints = [];
        for (const item of q) {
          try {
            const res = await logActionToSheet(item.action, item.details);
            if (res && res.ok) {
              // mark this fingerprint as successfully sent
              sentFingerprints.push(item.fingerprint);
              // record any set ids that were sent so we avoid re-sending them later
              try {
                if (item.action === 'log_set') {
                  let parsed = item.details;
                  if (typeof item.details === 'string') {
                    try { parsed = JSON.parse(item.details); } catch (e) { parsed = null; }
                  }
                  if (parsed && Array.isArray(parsed.sets)) {
                    const ids = parsed.sets.map(s => s && s.id).filter(Boolean);
                    if (ids.length) addLoggedSetIds(ids);
                  }
                }
              } catch (e) {}
            } else {
              remaining.push(item);
            }
          } catch (e) {
            remaining.push(item);
          }
        }
        // To avoid races where the stored queue changed while we were sending,
        // read the latest queue and filter out any items we know were sent.
        try {
          let current = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
          if (sentFingerprints.length > 0 && Array.isArray(current) && current.length > 0) {
            current = current.filter((it) => !sentFingerprints.includes(it.fingerprint));
            // Remove any items from 'remaining' whose sets are already recorded on the client
            try {
              const loggedIds = new Set(loadLoggedSetIds());
              const filteredRemaining = (remaining || []).filter(r => {
                if (!r || !r.action) return true;
                if (r.action !== 'log_set') return true;
                let parsed = r.details;
                if (typeof r.details === 'string') {
                  try { parsed = JSON.parse(r.details); } catch (e) { parsed = null; }
                }
                if (!parsed || !Array.isArray(parsed.sets)) return true;
                // if ALL set ids are already logged, drop this queued item
                const allLogged = parsed.sets.every(s => s && s.id && loggedIds.has(s.id));
                return !allLogged;
              });
              // merge any items that failed during this run (filteredRemaining) ensuring order is preserved
              const merged = current.concat(filteredRemaining.filter(r => !current.some(c => c.fingerprint === r.fingerprint)));
              localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(merged));
            } catch (e) {
              const remainingFingerprints = new Set((remaining || []).map(r => r.fingerprint));
              const merged = current.concat(remaining.filter(r => !current.some(c => c.fingerprint === r.fingerprint)));
              localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(merged));
            }
          } else {
            localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(remaining));
          }
        } catch (e) {
          // fallback to the conservative write
          localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(remaining));
        }
        updateSyncStatus();
        return { ok: true, remaining: remaining.length };
      } catch (e) {
        console.warn('Flush queue error', e);
        updateSyncStatus();
        return { ok: false, error: String(e) };
      }
    }

    // --- Queue viewer & management UI ---
    const queueListEl = document.getElementById('queueList');
    const retryQueueBtn = document.getElementById('retryQueue');
    const clearQueueBtn = document.getElementById('clearQueue');
    const downloadQueueBtn = document.getElementById('downloadQueue');

    function renderQueue() {
      try {
        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
        if (!queueListEl) return;
        queueListEl.innerHTML = '';
        if (!q || q.length === 0) {
          queueListEl.textContent = 'No pending actions';
          return;
        }
        q.forEach((item, idx) => {
          const el = document.createElement('div');
          el.style.display = 'flex';
          el.style.justifyContent = 'space-between';
          el.style.alignItems = 'center';
          el.style.padding = '6px 4px';
          el.style.borderBottom = '1px solid rgba(255,255,255,0.03)';
          const left = document.createElement('div');
          left.style.flex = '1';
          left.innerHTML = `<div><strong>${item.action}</strong> <span style="opacity:0.7">${new Date(item.ts).toLocaleString()}</span></div><div style="opacity:0.85">${String(item.details).slice(0,200)}</div>`;
          const right = document.createElement('div');
          right.style.display = 'flex';
          right.style.gap = '6px';
          const retryBtn = document.createElement('button');
          retryBtn.textContent = 'Retry';
          retryBtn.className = 'secondary';
          retryBtn.addEventListener('click', async () => {
            retryBtn.disabled = true;
            try {
              const res = await logActionToSheet(item.action, item.details);
              if (res && res.ok) {
                // remove any queued items matching this fingerprint (safer than splice-by-index)
                try {
                  const q2 = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
                  const filtered = q2.filter((it) => it.fingerprint !== item.fingerprint);
                  localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(filtered));
                } catch (e) {
                  // ignore
                }
                // record logged set ids for log_set
                try {
                  if (item.action === 'log_set') {
                    let parsed = item.details;
                    if (typeof item.details === 'string') {
                      try { parsed = JSON.parse(item.details); } catch (e) { parsed = null; }
                    }
                    if (parsed && Array.isArray(parsed.sets)) {
                      const ids = parsed.sets.map(s => s && s.id).filter(Boolean);
                      if (ids.length) addLoggedSetIds(ids);
                    }
                  }
                } catch (e) {}
                renderQueue();
                updateSyncStatus();
                flashStatus('Retried and removed ‚úîÔ∏è');
              } else {
                flashStatus('Retry failed (see console)');
                console.warn('Retry response', res);
              }
            } catch (e) {
              console.warn('Retry error', e);
              flashStatus('Retry failed');
            }
            retryBtn.disabled = false;
          });
          const delBtn = document.createElement('button');
          delBtn.textContent = 'Remove';
          delBtn.className = 'secondary';
          delBtn.addEventListener('click', () => {
            try {
              const q2 = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
              const filtered = q2.filter((it) => it.fingerprint !== item.fingerprint);
              localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(filtered));
            } catch (e) {
              // ignore
            }
            renderQueue();
            updateSyncStatus();
            flashStatus('Removed from queue');
          });
          right.appendChild(retryBtn);
          right.appendChild(delBtn);
          el.appendChild(left);
          el.appendChild(right);
          queueListEl.appendChild(el);
        });
      } catch (e) {
        console.warn('Render queue error', e);
      }
    }

    retryQueueBtn.addEventListener('click', async () => {
      retryQueueBtn.disabled = true;
      flashStatus('Retrying queue‚Ä¶', 2000);
      await flushQueue();
      renderQueue();
      retryQueueBtn.disabled = false;
    });

    clearQueueBtn.addEventListener('click', () => {
      localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify([]));
      renderQueue();
      updateSyncStatus();
      flashStatus('Queue cleared');
    });

    downloadQueueBtn.addEventListener('click', () => {
      const q = localStorage.getItem(ACTION_QUEUE_KEY) || '[]';
      const blob = new Blob([q], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `gym-log-queue-${new Date().toISOString()}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      flashStatus('Queue downloaded');
    });

    // render initially
    setTimeout(renderQueue, 800);

    // Attempt to flush when connection returns
    window.addEventListener('online', () => {
      updateSyncStatus();
      setTimeout(flushQueue, 800);
    });
    window.addEventListener('offline', updateSyncStatus);
    // Try flushing shortly after load
    window.addEventListener('load', () => {
      setTimeout(() => {
        updateSyncStatus();
        flushQueue();
      }, 1200);
    });
  </script>
</body>
</html>
