<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Gym Log</title>

  <!-- PWA basics -->
  <meta name="theme-color" content="#111827" />
  <link rel="manifest" href="./manifest.json" />

  <!-- Nice-to-haves (Android/Chrome + iOS-ish) -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="GymLog" />

  <!-- Optional: you can add an iOS icon later if you want -->
  <!-- <link rel="apple-touch-icon" href="./icon-192.png" /> -->

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 16px;
      background: #111827;
      color: #f9fafb;
    }

    h1 {
      margin: 0 0 12px;
      font-size: 1.4rem;
    }

    .hint {
      margin: 0 0 12px;
      opacity: 0.75;
      font-size: 0.95rem;
      line-height: 1.3;
    }

    textarea {
      width: 100%;
      min-height: 240px;
      padding: 12px;
      font-size: 16px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: #f9fafb;
      outline: none;
      resize: vertical;
      box-sizing: border-box;
    }

    textarea:focus {
      border-color: rgba(124, 58, 237, 0.7);
      box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.25);
    }

    .row {
      display: flex;
      gap: 10px;
      margin-top: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    button {
      padding: 12px 16px;
      font-size: 16px;
      border-radius: 10px;
      border: none;
      background: #7c3aed;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }

    button.secondary {
      background: rgba(255,255,255,0.12);
      color: #f9fafb;
    }

    .status {
      font-size: 0.95rem;
      opacity: 0.85;
      min-height: 1.2em;
    }

    .tiny {
      font-size: 0.85rem;
      opacity: 0.75;
      margin-top: 10px;
      line-height: 1.35;
    }

    code {
      background: rgba(255,255,255,0.08);
      padding: 2px 6px;
      border-radius: 6px;
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
  </style>
</head>

<body>
  <h1>üèãÔ∏è Gym Log</h1>
  <p class="hint">Type your workout notes. It auto-saves locally on this device.</p>

  <textarea
    id="log"
    placeholder="e.g.
Bench Press
20kg x 12
30kg x 8
Notes: felt good"
  ></textarea>

  <div class="row">
    <button id="save" type="button">Save</button>
    <button class="secondary" id="clear" type="button">Clear</button>
    <div class="status" id="status"></div>
  </div>
  <div class="status" id="syncStatus" style="margin-top:6px; font-size:0.9rem; opacity:0.9"></div>

  <div class="row">
    <button id="backupDrive" class="secondary" type="button">Backup to Drive</button>
    <button id="restoreDrive" class="secondary" type="button">Restore from Drive</button>
    <button id="exportBtn" class="secondary" type="button">Export (.txt)</button>
    <button id="importBtn" class="secondary" type="button">Import (.txt)</button>
    <input id="fileInput" type="file" accept="text/plain" style="display:none" />
  </div>

  <div class="row">
    <button id="setSheetToken" class="secondary" type="button">Set Sheet Token</button>
    <button id="testLog" class="secondary" type="button">Test Log</button>
    <button id="newSession" class="secondary" type="button">New Session</button>
    <button id="addExercise" class="secondary" type="button">Add Exercise</button>
    <button id="addSet" class="secondary" type="button">Add Set</button>
    <button id="exportRows" class="secondary" type="button">Export rows to Sheet</button>
  </div>

  <div class="tiny" id="pwaInfo"></div>

  <!-- Add-Set modal -->
  <div id="addSetModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); align-items:center; justify-content:center; z-index:9999;">
    <div style="background:#0b1220; padding:16px; border-radius:12px; width:92%; max-width:420px; box-shadow:0 10px 30px rgba(0,0,0,0.6); color:#f9fafb;">
      <h3 style="margin:0 0 8px; font-size:1.1rem;">Add Set(s)</h3>
      <div style="display:flex; gap:8px; flex-direction:column;">
        <label class="mono" style="font-size:0.9rem; opacity:0.9">Exercise</label>
        <select id="modalExerciseSelect" style="padding:8px; border-radius:8px; background:rgba(255,255,255,0.04); color:#f9fafb; border:1px solid rgba(255,255,255,0.06)">
          <option value="__new__">-- New exercise --</option>
        </select>
        <input id="modalExerciseNew" placeholder="If new: name" style="padding:8px; border-radius:8px; background:rgba(255,255,255,0.03); color:#f9fafb; border:1px solid rgba(255,255,255,0.06); display:none;" />

        <div style="display:flex; gap:8px;">
          <div style="flex:1">
            <label class="mono" style="font-size:0.9rem; opacity:0.9">Sets</label>
            <input id="modalSets" type="number" min="1" value="3" style="width:100%; padding:8px; border-radius:8px;" />
          </div>
          <div style="flex:1">
            <label class="mono" style="font-size:0.9rem; opacity:0.9">Reps</label>
            <input id="modalReps" type="number" min="0" value="8" style="width:100%; padding:8px; border-radius:8px;" />
          </div>
        </div>

        <div style="display:flex; gap:8px;">
          <div style="flex:1">
            <label class="mono" style="font-size:0.9rem; opacity:0.9">Weight</label>
            <input id="modalWeight" type="number" step="0.5" style="width:100%; padding:8px; border-radius:8px;" />
          </div>
          <div style="width:110px">
            <label class="mono" style="font-size:0.9rem; opacity:0.9">Unit</label>
            <select id="modalUnit" style="width:100%; padding:8px; border-radius:8px;">
              <option value="kg">kg</option>
              <option value="lb">lb</option>
              <option value="">(none)</option>
            </select>
          </div>
        </div>

        <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:8px;">
          <button id="modalCancel" class="secondary" type="button">Cancel</button>
          <button id="modalAdd" type="button">Add</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const STORAGE_KEY = "gym-log";

    const textarea = document.getElementById("log");
    const statusEl = document.getElementById("status");
    const saveBtn = document.getElementById("save");
    const clearBtn = document.getElementById("clear");
    const pwaInfo = document.getElementById("pwaInfo");

    // Load saved data on startup
    textarea.value = localStorage.getItem(STORAGE_KEY) || "";

    function flashStatus(msg, ms = 1500) {
      statusEl.textContent = msg;
      window.clearTimeout(flashStatus._t);
      flashStatus._t = window.setTimeout(() => (statusEl.textContent = ""), ms);
    }

    function saveNow() {
      localStorage.setItem(STORAGE_KEY, textarea.value);
      flashStatus("Saved locally ‚úîÔ∏è");
      // Try to send save event to Google Sheet (or queue if offline)
      try {
        enqueueAction('save', JSON.stringify({ length: textarea.value.length })).catch(() => {});
      } catch (e) {
        // ignore
      }
    }

  saveBtn.addEventListener("click", saveNow);

    // Auto-save as you type (debounced)
    let t = null;
    textarea.addEventListener("input", () => {
      clearTimeout(t);
      t = setTimeout(() => {
        localStorage.setItem(STORAGE_KEY, textarea.value);
        flashStatus("Auto-saved‚Ä¶", 800);
      }, 300);
    });

    // --- Structured data helpers (exercises + sets store) ---
    const setSheetTokenBtn = document.getElementById('setSheetToken');
    const testLogBtn = document.getElementById('testLog');
    const newSessionBtn = document.getElementById('newSession');
    const addExerciseBtn = document.getElementById('addExercise');
    const addSetBtn = document.getElementById('addSet');
    const exportRowsBtn = document.getElementById('exportRows');

    const EXERCISES_KEY = 'gym-exercises';
    const SETS_KEY = 'gym-sets';

    // Exercises are a global list saved to localStorage so they persist across sessions/devices (and can be synced to the Sheet).
    function loadExercises() {
      try {
        return JSON.parse(localStorage.getItem(EXERCISES_KEY) || '[]');
      } catch (e) {
        return [];
      }
    }

    function saveExercises(arr) {
      localStorage.setItem(EXERCISES_KEY, JSON.stringify(arr || []));
      updateExerciseSelect();
    }

    function loadSets() {
      try {
        return JSON.parse(localStorage.getItem(SETS_KEY) || '[]');
      } catch (e) {
        return [];
      }
    }

    function saveSets(arr) {
      localStorage.setItem(SETS_KEY, JSON.stringify(arr || []));
    }

    function updateExerciseSelect() {
      const select = document.getElementById('modalExerciseSelect');
      const exercises = loadExercises();
      // keep the default new option
      const current = select && select.value;
      if (!select) return;
      select.innerHTML = '<option value="__new__">-- New exercise --</option>';
      for (const ex of exercises) {
        const opt = document.createElement('option');
        opt.value = String(ex.id);
        opt.textContent = ex.name;
        select.appendChild(opt);
      }
      // try to reselect previous value
      if (current) select.value = current;
    }

    function loadStructuredData() {
      // Keep backward compatibility: if STORAGE_KEY contains a sessions-based v2 payload,
      // we won't delete it ‚Äî but the app now prefers the global exercises + sets stores.
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      try {
        return JSON.parse(raw);
      } catch (e) {
        return null;
      }
    }

    function saveStructuredData(obj) {
      // Deprecated for new flow ‚Äî keep for compatibility
      localStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
      flashStatus('Saved ‚úîÔ∏è');
    }

    function getCurrentSession(data) {
      // Sessions are optional in the new model. Return null unless the old schema is present.
      const d = data || loadStructuredData();
      if (!d || !d.sessions || d.sessions.length === 0) return null;
      return d.sessions[d.sessions.length - 1];
    }

    async function newSession() {
      // Sessions are optional; keep behavior for backward compatibility
      const d = loadStructuredData() || { version: 2, sessions: [] };
      const session = { id: Date.now(), date: new Date().toISOString(), notes: '', exercises: [] };
      d.sessions.push(session);
      saveStructuredData(d);
      flashStatus('New session created');
      try { await enqueueAction('new_session', JSON.stringify({ id: session.id, date: session.date })); } catch (e) {}
    }

    async function addExercise() {
      // Add exercise to global exercises list so it's available across sessions/devices
      const name = prompt('Exercise name (e.g. Bench Press)');
      if (!name) return flashStatus('Cancelled', 1200);
      const exercises = loadExercises();
      const ex = { id: Date.now(), name: name.trim(), notes: '' };
      exercises.push(ex);
      saveExercises(exercises);
      flashStatus('Exercise added');
      try { await enqueueAction('upsert_exercise', JSON.stringify(ex)); } catch (e) {}
    }

    async function addSet() {
      // Open modal UI for adding sets (prefill exercises)
      const d = loadStructuredData();
      let session = getCurrentSession(d);
      if (!session) {
        // create a session silently
        session = { id: Date.now(), date: new Date().toISOString(), notes: '', exercises: [] };
        d.sessions.push(session);
        saveStructuredData(d);
      }

      const select = document.getElementById('modalExerciseSelect');
      const newInput = document.getElementById('modalExerciseNew');
      const setsInput = document.getElementById('modalSets');
      const repsInput = document.getElementById('modalReps');
      const weightInput = document.getElementById('modalWeight');
      const unitSelect = document.getElementById('modalUnit');
      const modal = document.getElementById('addSetModal');

      // populate exercise list from global exercises store
      updateExerciseSelect();
      const exercises = loadExercises();
      if (exercises && exercises.length) {
        select.value = String(exercises[exercises.length - 1].id);
        newInput.style.display = 'none';
      } else {
        select.value = '__new__';
        newInput.style.display = '';
      }

      // preset values
      setsInput.value = 3;
      repsInput.value = 8;
      weightInput.value = '';
      unitSelect.value = 'kg';

      // show modal
      modal.style.display = 'flex';

      // handlers
      function onSelectChange() {
        if (select.value === '__new__') newInput.style.display = '';
        else newInput.style.display = 'none';
      }

      function closeModal() {
        modal.style.display = 'none';
        select.removeEventListener('change', onSelectChange);
        cancelBtn.removeEventListener('click', onCancel);
        addBtn.removeEventListener('click', onAdd);
      }

      function onCancel() {
        closeModal();
        flashStatus('Cancelled', 900);
      }

      async function onAdd() {
        const setsCount = Math.max(1, Number(setsInput.value) || 1);
        const repsVal = repsInput.value === '' ? null : Number(repsInput.value);
        const weightVal = weightInput.value === '' ? '' : String(weightInput.value) + (unitSelect.value ? unitSelect.value : '');
        let exObj = null;
        if (select.value === '__new__') {
          const name = newInput.value && newInput.value.trim();
          if (!name) return flashStatus('Enter exercise name', 1500);
          exObj = { id: Date.now(), name: name, sets: [], notes: '' };
          session.exercises.push(exObj);
        } else {
          exObj = session.exercises.find(e => String(e.id) === String(select.value));
          if (!exObj) {
            flashStatus('Exercise not found', 1500);
            return;
          }
        }

        // Add sets with slightly different timestamps to the global sets store
        const sets = loadSets();
        for (let i = 0; i < setsCount; i++) {
          const ts = new Date(Date.now() + i * 1000).toISOString();
          const setObj = { id: Date.now() + i, exerciseId: exObj.id, ts, reps: repsVal, weight: weightVal };
          sets.push(setObj);
        }
        saveSets(sets);
        closeModal();
          flashStatus(`${setsCount} set(s) added to ${exObj.name}`);
          try { await enqueueAction('add_set', JSON.stringify({ exerciseId: exObj.id, exercise: exObj.name, sets: setsCount })); } catch (e) {}
      }

      select.addEventListener('change', onSelectChange);
      const cancelBtn = document.getElementById('modalCancel');
      const addBtn = document.getElementById('modalAdd');
      cancelBtn.addEventListener('click', onCancel);
      addBtn.addEventListener('click', onAdd);
    }

    async function exportRowsToSheet() {
      // Flatten global sets list into rows for the Sheet. Each set is one row.
      const sets = loadSets();
      const exercises = loadExercises().reduce((m, e) => { m[e.id] = e; return m; }, {});
      const rows = [];
      for (let i = 0; i < sets.length; i++) {
        const set = sets[i];
        const ex = exercises[set.exerciseId] || { name: '' };
        rows.push({
          exerciseId: set.exerciseId,
          exercise: ex.name,
          setIndex: null,
          setTs: set.ts,
          reps: set.reps,
          weight: set.weight,
          notes: set.notes || ''
        });
      }
      if (rows.length === 0) return flashStatus('No structured rows to export', 2000);
      flashStatus('Exporting rows‚Ä¶', 5000);
      try {
        const res = await enqueueAction('export_rows', JSON.stringify({ rows }));
        if (res && res.ok) {
          flashStatus('Exported rows to Sheet ‚úîÔ∏è', 2500);
        } else if (res && res.queued) {
          flashStatus('Export queued for sync ‚úîÔ∏è', 2500);
        } else {
          console.warn('Export rows response', res);
          flashStatus('Export failed (see console)', 4000);
        }
      } catch (e) {
        console.warn(e);
        flashStatus('Export failed', 3000);
      }
    }

    // --- small UI bindings for token & test log ---
    setSheetTokenBtn.addEventListener('click', () => {
      try {
        const existing = localStorage.getItem('gym-log-sheet-token') || '';
        const val = prompt('Enter sheet secret token (leave empty to clear)', existing);
        if (val === null) return; // cancelled
        if (!val) {
          localStorage.removeItem('gym-log-sheet-token');
          flashStatus('Sheet token cleared (not used)');
          return;
        }
        localStorage.setItem('gym-log-sheet-token', val);
        flashStatus('Sheet token saved locally ‚úîÔ∏è', 2000);
      } catch (e) {
        flashStatus('Could not save token (storage error)');
      }
    });

    testLogBtn.addEventListener('click', async () => {
      testLogBtn.disabled = true;
      flashStatus('Sending test log‚Ä¶');
      try {
        const res = await logActionToSheet('test', JSON.stringify({ ts: new Date().toISOString(), url: window.location.href }));
        console.log('Test log response', res);
        if (res && res.ok) {
          flashStatus('Test log sent ‚úîÔ∏è', 2000);
        } else {
          flashStatus('Test failed (see console)', 4000);
        }
      } catch (e) {
        console.error(e);
        flashStatus('Test failed', 3000);
      }
      testLogBtn.disabled = false;
    });

    newSessionBtn.addEventListener('click', () => newSession());
    addExerciseBtn.addEventListener('click', () => addExercise());
    addSetBtn.addEventListener('click', () => addSet());
    exportRowsBtn.addEventListener('click', () => exportRowsToSheet());

    clearBtn.addEventListener("click", () => {
      textarea.value = "";
      localStorage.removeItem(STORAGE_KEY);
      flashStatus("Cleared ‚úîÔ∏è");
      try {
        enqueueAction('clear', '').catch(() => {});
      } catch (e) {}
    });

    // --- Service worker registration (helps installability + offline) ---
    // sw.js must be in the same folder as this index.html
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", async () => {
        try {
          const reg = await navigator.serviceWorker.register("./sw.js");
          // Optional: you can show this if you want
          // console.log("Service worker registered:", reg.scope);
        } catch (err) {
          console.warn("Service worker registration failed:", err);
          flashStatus("SW failed to register (check console) ‚ö†Ô∏è", 2000);
        }
      });
    }

    // Tiny debug info to help confirm install / context
    const isStandalone =
      window.matchMedia("(display-mode: standalone)").matches ||
      window.navigator.standalone === true;

    const href = window.location.href;
    pwaInfo.innerHTML = isStandalone
      ? "‚úÖ Running as an installed app (standalone)."
      : `‚ÑπÔ∏è Not installed yet.<br/>
         In Chrome: menu ‚ãÆ ‚Üí <b>Install app</b> (or <b>Add to Home screen</b>).<br/>
         If you don‚Äôt see it, confirm these load with 200 OK:<br/>
         ‚Ä¢ <code>manifest.json</code> ‚Ä¢ <code>sw.js</code> ‚Ä¢ icons.<br/>
         <span class="mono">URL:</span> <code>${href}</code>`;
  </script>
  <!-- Google Identity Services (for Drive backup) -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <script>
    // --- Backup / Restore helpers ---
    // STORAGE_KEY and textarea exist in the outer script above
    const backupBtn = document.getElementById('backupDrive');
    const restoreBtn = document.getElementById('restoreDrive');
    const exportBtn = document.getElementById('exportBtn');
    const importBtn = document.getElementById('importBtn');
    const fileInput = document.getElementById('fileInput');

  // Google Drive OAuth client id placeholder. Replace with your own client ID.
  const GSI_CLIENT_ID = 'YOUR_CLIENT_ID.apps.googleusercontent.com';
    const GSI_SCOPE = 'https://www.googleapis.com/auth/drive.file'; // creates files visible in Drive

    let gsiTokenClient = null;
    let gsiAccessToken = null;

    function initGsiClient() {
      if (!window.google || !google.accounts || !google.accounts.oauth2) return;
      gsiTokenClient = google.accounts.oauth2.initTokenClient({
        client_id: GSI_CLIENT_ID,
        scope: GSI_SCOPE,
        callback: (tokenResponse) => {
          if (tokenResponse && tokenResponse.access_token) {
            gsiAccessToken = tokenResponse.access_token;
            flashStatus('Google Drive: signed in ‚úîÔ∏è', 2000);
          } else {
            flashStatus('Google Drive: sign-in failed', 3000);
          }
        }
      });
    }

    // --- Logging to Google Sheets (Apps Script) ---
  // Configure these placeholders with your Apps Script web app URL and secret token.
  const SHEETS_WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbwHk6otl1AmaEIBzZnPvfQX9055EOY2t3AnrqFFNpK93axNDtnF6r5AmkjO6XO505M2ew/exec';
  // Removed secret from repo. If your Apps Script now accepts anonymous posts,
  // leave this empty. To use a secret again, set it locally in your browser
  // (e.g. via localStorage) instead of committing it here.
  const SHEETS_SECRET_TOKEN = '';
  const SHEETS_LOCAL_TOKEN_KEY = 'gym-log-sheet-token';

    async function logActionToSheet(action, details = '') {
      if (!SHEETS_WEB_APP_URL || SHEETS_WEB_APP_URL.includes('REPLACE_WITH')) return false;
      const payload = { action, details };
      // Include token only when explicitly set in constant or locally in browser storage
      if (SHEETS_SECRET_TOKEN) payload._token = SHEETS_SECRET_TOKEN;
      try {
        const localToken = localStorage.getItem(SHEETS_LOCAL_TOKEN_KEY);
        if (localToken) payload._token = localToken;
      } catch (e) {
        // ignore localStorage errors (e.g., privacy mode)
      }
      try {
        // Send as plain text (no custom Content-Type) to avoid triggering CORS preflight.
        // Apps Script doPost can read the raw body from e.postData.contents and JSON.parse it.
        const res = await fetch(SHEETS_WEB_APP_URL, {
          method: 'POST',
          body: JSON.stringify(payload),
          // don't set headers here to keep request simple (text/plain) and avoid preflight
        });
        if (!res.ok) {
          // non-2xx (may also be blocked by CORS and thrown as an exception)
          const txt = await res.text().catch(() => '<no body>');
          console.warn('Log failed', res.status, txt);
          return { ok: false, status: res.status, text: txt };
        }
        // Some deployments (if CORS is misconfigured) may not allow reading the response; handle safely
        try {
          const json = await res.json();
          return json;
        } catch (e) {
          return { ok: true };
        }
      } catch (err) {
        console.warn('Log error', err);
        return { ok: false, error: String(err) };
      }
    }

    // --- Offline queue & sync helpers ---
    const ACTION_QUEUE_KEY = 'gym-log-queue';
    const syncStatusEl = document.getElementById('syncStatus');

    function updateSyncStatus() {
      try {
        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
        const pending = q.length || 0;
        if (!navigator.onLine) {
          syncStatusEl.textContent = `‚ö†Ô∏è Offline ‚Äî ${pending} pending action(s)`;
        } else if (pending > 0) {
          syncStatusEl.textContent = `üîÅ ${pending} pending action(s) ‚Äî syncing...`;
        } else {
          syncStatusEl.textContent = `‚úÖ Online ‚Äî all synced`;
        }
      } catch (e) {
        syncStatusEl.textContent = navigator.onLine ? '‚úÖ Online' : '‚ö†Ô∏è Offline';
      }
    }

    async function enqueueAction(action, details = '') {
      const fingerprint = JSON.stringify({ action, details });
      const item = { action, details, ts: new Date().toISOString(), fingerprint };
      // Try to send immediately when online
      if (navigator.onLine) {
        try {
          const res = await logActionToSheet(action, details);
          if (res && res.ok) {
            // Remove any previously queued items that match this action/details to avoid duplicates
            try {
              const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
              const filtered = q.filter((it) => it.fingerprint !== fingerprint);
              if (filtered.length !== q.length) {
                localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(filtered));
              }
            } catch (e) {
              // ignore
            }
            updateSyncStatus();
            return { ok: true, sent: true, res };
          }
        } catch (e) {
          // fall through to queueing
        }
      }
      // queue locally
      try {
        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
        // avoid exact-duplicate queue entries (same fingerprint)
        const exists = q.some((it) => it.fingerprint === fingerprint);
        if (!exists) q.push(item);
        q.push(item);
        localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(q));
        updateSyncStatus();
        return { ok: false, queued: true };
      } catch (e) {
        console.warn('Queue error', e);
        return { ok: false, error: String(e) };
      }
    }

    async function flushQueue() {
      try {
        const q = JSON.parse(localStorage.getItem(ACTION_QUEUE_KEY) || '[]');
        if (!q || q.length === 0) return updateSyncStatus();
        updateSyncStatus();
        const remaining = [];
        for (const item of q) {
          try {
            const res = await logActionToSheet(item.action, item.details);
            if (!(res && res.ok)) {
              remaining.push(item);
            }
          } catch (e) {
            remaining.push(item);
          }
        }
        localStorage.setItem(ACTION_QUEUE_KEY, JSON.stringify(remaining));
        updateSyncStatus();
        return { ok: true, remaining: remaining.length };
      } catch (e) {
        console.warn('Flush queue error', e);
        updateSyncStatus();
        return { ok: false, error: String(e) };
      }
    }

    // Attempt to flush when connection returns
    window.addEventListener('online', () => {
      updateSyncStatus();
      setTimeout(flushQueue, 800);
    });
    window.addEventListener('offline', updateSyncStatus);
    // Try flushing shortly after load
    window.addEventListener('load', () => {
      setTimeout(() => {
        updateSyncStatus();
        flushQueue();
      }, 1200);
    });

    window.addEventListener('load', () => {
      // Give the GSI script a moment and init
      setTimeout(initGsiClient, 600);
    });

    function requestDriveToken(interactive = true) {
      if (!gsiTokenClient) return flashStatus('GSI not ready', 2000);
      gsiTokenClient.requestAccessToken({ prompt: interactive ? 'consent' : '' });
    }

    // Upload backup text to Drive (creates a file in user's Drive root)
    async function uploadBackupToDrive(text, filename = `gym-log-backup-${new Date().toISOString()}.txt`) {
      if (!gsiAccessToken) {
        requestDriveToken(true);
        return;
      }

      const metadata = { name: filename };
      const boundary = '-------314159265358979323846';
      const delimiter = `\r\n--${boundary}\r\n`;
      const closeDelimiter = `\r\n--${boundary}--`;

      const multipartRequestBody =
        delimiter +
        'Content-Type: application/json; charset=UTF-8\r\n\r\n' +
        JSON.stringify(metadata) +
        '\r\n' +
        delimiter +
        'Content-Type: text/plain\r\n\r\n' +
        text +
        closeDelimiter;

      const res = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name', {
        method: 'POST',
        headers: {
          Authorization: 'Bearer ' + gsiAccessToken,
          'Content-Type': `multipart/related; boundary=${boundary}`
        },
        body: multipartRequestBody
      });

      if (!res.ok) {
        const txt = await res.text();
        console.error('Drive upload failed', res.status, txt);
        flashStatus('Drive upload failed', 3000);
        return null;
      }

      const payload = await res.json();
      flashStatus('Backup uploaded to Drive ‚úîÔ∏è', 2500);
      try {
        enqueueAction('backup_drive_done', JSON.stringify(payload)).catch(() => {});
      } catch (e) {}
      return payload;
    }

    // List files created by this app (search by name prefix)
    async function listBackups() {
      if (!gsiAccessToken) {
        requestDriveToken(true);
        return [];
      }
      const q = `name contains 'gym-log-backup'`;
      const url = `https://www.googleapis.com/drive/v3/files?q=${encodeURIComponent(q)}&fields=files(id,name,modifiedTime)`;
      const res = await fetch(url, { headers: { Authorization: 'Bearer ' + gsiAccessToken } });
      if (!res.ok) return [];
      const data = await res.json();
      return data.files || [];
    }

    async function downloadBackup(fileId) {
      if (!gsiAccessToken) {
        requestDriveToken(true);
        return null;
      }
      const url = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`;
      const res = await fetch(url, { headers: { Authorization: 'Bearer ' + gsiAccessToken } });
      if (!res.ok) {
        flashStatus('Download failed', 3000);
        return null;
      }
      return await res.text();
    }

    // --- Export / Import (local) ---
    function exportToFile(text, filename = 'gym-log-export.txt') {
      const blob = new Blob([text], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      flashStatus('Exported .txt ‚úîÔ∏è', 1800);
      try {
        enqueueAction('export', JSON.stringify({ filename })).catch(() => {});
      } catch (e) {}
    }

    fileInput.addEventListener('change', async (ev) => {
      const f = ev.target.files && ev.target.files[0];
      if (!f) return;
      const txt = await f.text();
      textarea.value = txt;
      localStorage.setItem(STORAGE_KEY, txt);
      flashStatus('Imported .txt ‚úîÔ∏è', 1800);
      try {
        enqueueAction('import', JSON.stringify({ name: f.name, size: f.size })).catch(() => {});
      } catch (e) {}
      fileInput.value = '';
    });

    // --- button bindings ---
    exportBtn.addEventListener('click', () => exportToFile(textarea.value));

    importBtn.addEventListener('click', () => fileInput.click());

    backupBtn.addEventListener('click', async () => {
      // If client id not replaced, notify user
      if (GSI_CLIENT_ID.includes('YOUR_CLIENT_ID')) {
        flashStatus('Please set your Google Client ID in the code to use Drive backup.', 4000);
        return;
      }
      // Ensure token client is initialized
      if (!gsiTokenClient) initGsiClient();
      if (!gsiAccessToken) {
        requestDriveToken(true);
        // Wait a short while for interactive consent to complete before attempting upload
        setTimeout(() => uploadBackupToDrive(textarea.value), 1200);
        return;
      }
      await uploadBackupToDrive(textarea.value);
    });

    restoreBtn.addEventListener('click', async () => {
      if (GSI_CLIENT_ID.includes('YOUR_CLIENT_ID')) {
        flashStatus('Please set your Google Client ID in the code to use Drive restore.', 4000);
        return;
      }
      if (!gsiTokenClient) initGsiClient();
      if (!gsiAccessToken) {
        requestDriveToken(true);
        setTimeout(async () => {
          const files = await listBackups();
          if (!files || files.length === 0) return flashStatus('No backups found', 2000);
          // pick the most recent by modifiedTime
          files.sort((a,b) => new Date(b.modifiedTime) - new Date(a.modifiedTime));
          const content = await downloadBackup(files[0].id);
          if (content != null) {
            textarea.value = content;
            localStorage.setItem(STORAGE_KEY, content);
            flashStatus('Restored from Drive ‚úîÔ∏è', 2000);
            try {
              enqueueAction('restore_drive', JSON.stringify({ id: files[0].id, name: files[0].name })).catch(() => {});
            } catch (e) {}
          }
        }, 1200);
        return;
      }

      const files = await listBackups();
      if (!files || files.length === 0) return flashStatus('No backups found', 2000);
      files.sort((a,b) => new Date(b.modifiedTime) - new Date(a.modifiedTime));
      const content = await downloadBackup(files[0].id);
      if (content != null) {
        textarea.value = content;
        localStorage.setItem(STORAGE_KEY, content);
        flashStatus('Restored from Drive ‚úîÔ∏è', 2000);
        try {
          enqueueAction('restore_drive', JSON.stringify({ id: files[0].id, name: files[0].name })).catch(() => {});
        } catch (e) {}
      }
    });
  </script>
</body>
</html>
